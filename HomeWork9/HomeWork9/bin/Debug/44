<!doctype html><html lang="zh" data-server-rendered="true" data-v-52866abc><head><title>Qiana_wq的博客_Qiana_Wu_CSDN博客-c++,面试题,Linux领域博主</title> <meta name="keywords" content=""> <meta name="description" content="Qiana_Wu擅长c++,面试题,Linux,等方面的知识,Qiana_Wu关注Linux,C/C++,Java,MySQL,Redis,Spring,Spring Boot领域."> <meta http-equiv="content-type" content="text/html;charset=utf-8"> <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui"> <meta name="referrer" content="always"> <meta http-equiv="Cache-Control" content="no-siteapp"> <meta name="applicable-device" content="pc"> <!----> <!----> 
        <script src="https://g.csdnimg.cn/tingyun/1.8.5/user.js"></script>
       <link rel="shortcut icon" href="https://g.csdnimg.cn/static/logo/favicon32.ico" type="image/x-icon"> <link rel="canonical" href="https://blog.csdn.net/Qiana_"> <!----> 
          <meta name="toolbar" content={"type":"0"} />
       
          <meta name="report" content={"spm":"1001.2014"} />
       <script src="https://g.csdnimg.cn/??lib/jquery/1.12.4/jquery.min.js,user-tooltip/2.2/user-tooltip.js,lib/qrcode/1.0.0/qrcode.min.js"></script> <script src='//g.csdnimg.cn/common/csdn-report/report.js' type='text/javascript'></script> <!----> 
          <script src="https://g.csdnimg.cn/login-box/1.1.4/login-box.js"></script>
       <!----> <!----><link rel="stylesheet" href="https://csdnimg.cn/release/cmsfe/public/css/common.ef9f4893.css"><link rel="stylesheet" href="https://csdnimg.cn/release/cmsfe/public/css/tpl/user-profile/index.698b4ce1.css"></head> <body><div id="app"><div><div class="main"><div class="page-container page-component"><div data-v-52866abc><div class="home_wrap" data-v-52866abc><div id="floor-user-profile_485" class="grey-bg" data-v-c9883966 data-v-52866abc><div comp-data="[object Object]" floor-data="[object Object]" data-v-80922f46 data-v-c9883966><div class="user-profile-head" data-v-d1dbb6f8 data-v-80922f46><div class="user-profile-head-banner" style="background-image:url(https://img-home.csdnimg.cn/images/20210120054229.jpg);" data-v-d1dbb6f8><div class="user-profile-wrapper" data-v-d1dbb6f8><h1 class="user-profile-title" style="color:#fff;" data-v-d1dbb6f8>Qiana_wq的博客</h1> <div class="user-profile-sub-title" style="color:#fff;" data-v-d1dbb6f8></div></div></div> <div class="user-profile-head-info user-profile-wrapper" data-v-d1dbb6f8><div class="user-profile-head-info-t clearfix" data-v-d1dbb6f8><!----> <div class="user-profile-avatar" data-v-d1dbb6f8><img src="https://profile.csdnimg.cn/8/B/6/1_qiana_" alt data-v-d1dbb6f8> <i class="user-gender-female" data-v-d1dbb6f8></i></div> <div class="user-profile-operate-btn" data-v-d1dbb6f8><a href="https://im.csdn.net/im/main.html?userName=Qiana_" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5471&quot;}" data-report-query="spm=3001.5471" class="user-profile-black-btn" data-v-d1dbb6f8>私信</a> <a href="javascript:;" data-report-click="{&quot;spm&quot;:&quot;3001.5472&quot;}" class="user-profile-red-btn" data-v-d1dbb6f8>关注</a> <!----></div></div> <div class="user-profile-head-info-m" data-v-d1dbb6f8><div class="user-profile-head-name" data-v-d1dbb6f8><div data-v-d1dbb6f8>Qiana_Wu</div> <div title="已加入 CSDN 5年" class="person-code-age" style="background-color:#C7E9FD;color:#1E68D8;" data-v-d1dbb6f8><img src="https://img-home.csdnimg.cn/images/20210108035952.gif" alt data-v-d1dbb6f8> <span data-v-d1dbb6f8>码龄5年</span></div> <div class="user-profile-icon" data-v-d1dbb6f8><a href="https://blog.csdn.net/blogdevteam/article/details/103478461" target="_blank" data-v-d1dbb6f8><img src="https://csdnimg.cn/identity/blog5.png" alt title="博客等级" data-v-d1dbb6f8></a> <a href="https://www.csdn.net/vip" target="_blank" data-v-d1dbb6f8><!----></a> <a href="https://i.csdn.net/#/user-center/auth" target="_blank" data-v-d1dbb6f8><!----></a> <a href="https://i.csdn.net/#/user-center/auth" target="_blank" data-v-d1dbb6f8><!----></a></div></div> <div class="user-profile-head-introduction" data-v-d1dbb6f8><p data-v-d1dbb6f8>
          坚持不懈的编程
        </p> <!----></div></div> <div class="user-profile-head-info-b" data-v-d1dbb6f8><ul data-v-d1dbb6f8><li data-v-d1dbb6f8><div class="user-profile-statistics-num" data-v-d1dbb6f8>103,113</div> <div class="user-profile-statistics-name" data-v-d1dbb6f8>被访问量</div></li> <li data-v-d1dbb6f8><a href="javascript:;" data-v-d1dbb6f8><div class="user-profile-statistics-num" data-v-d1dbb6f8>104</div> <div class="user-profile-statistics-name" data-v-d1dbb6f8>原创文章</div></a></li> <li data-v-d1dbb6f8><a href="https://blog.csdn.net/rank/list/total" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5476&quot;}" data-report-query="spm=3001.5476" data-v-d1dbb6f8><div class="user-profile-statistics-num" data-v-d1dbb6f8>49,354</div> <div class="user-profile-statistics-name" data-v-d1dbb6f8>作者排名</div></a></li> <li data-v-d1dbb6f8><a href="javascript:;" data-v-d1dbb6f8><div class="user-profile-statistics-num" data-v-d1dbb6f8>45</div> <div class="user-profile-statistics-name" data-v-d1dbb6f8>粉丝数量</div></a></li></ul></div></div></div> <div class="user-profile-body" data-v-3f0fdf46 data-v-80922f46><div class="user-profile-body-inner" data-v-3f0fdf46><div class="user-profile-body-left" data-v-3f0fdf46><div class="user-profile-aside" data-v-d487ed78 data-v-3f0fdf46><div class="user-general-info single-general-info" data-v-d487ed78><ul data-v-d487ed78><!----> <!----> <li class="user-general-info-join-csdn" data-v-d487ed78><i data-v-d487ed78></i> <span data-v-d487ed78>于</span> <span class="user-general-info-key-word" data-v-d487ed78>2016-10-27</span> <span data-v-d487ed78>加入CSDN</span></li></ul></div> <!----> <div class="user-achievement user-profile-aside-common-box" data-v-d487ed78><div class="aside-common-box-head" data-v-d487ed78>获得成就</div> <div class="aside-common-box-bottom" data-v-d487ed78><div class="aside-common-box-content" data-v-d487ed78><ul data-v-d487ed78><li data-v-d487ed78>
        <i style="background-image: url(https://img-home.csdnimg.cn/images/20210114022819.png)"></i>
        <div>获得<span>138</span>次点赞</div>
      </li><li data-v-d487ed78>
        <i style="background-image: url(https://img-home.csdnimg.cn/images/20210114022831.png)"></i>
        <div>内容获得<span>32</span>次评论</div>
      </li><li data-v-d487ed78>
        <i style="background-image: url(https://img-home.csdnimg.cn/images/20210114022828.png)"></i>
        <div>获得<span>441</span>次收藏</div>
      </li></ul></div></div></div> <div class="user-profile-medal user-profile-aside-common-box" data-v-d487ed78><div class="aside-common-box-head" data-v-d487ed78>荣誉勋章</div> <div class="aside-common-box-bottom" data-v-d487ed78><div class="aside-common-box-content" data-v-d487ed78><ul data-v-d487ed78><li data-nickname="Qiana_Wu" data-username="Qiana_" data-avatar="https://profile.csdnimg.cn/8/B/6/1_qiana_" data-report-click="{&quot;spm&quot;:&quot;3001.5481&quot;}" class="csdn-user-medal-btn" data-v-d487ed78><img src="https://csdnimg.cn/medal/qixiebiaobing1@240.png" alt data-v-d487ed78></li></ul></div> <button data-nickname="Qiana_Wu" data-username="Qiana_" data-avatar="https://profile.csdnimg.cn/8/B/6/1_qiana_" data-report-click="{&quot;spm&quot;:&quot;3001.5481&quot;}" class="aside-common-box-bottom-btn csdn-user-medal-btn" data-v-d487ed78>所有勋章<i class="el-icon-arrow-right" data-v-d487ed78></i></button></div></div> <div class="user-interest-area user-profile-aside-common-box" data-v-d487ed78><div class="aside-common-box-head" data-v-d487ed78>兴趣领域</div> <div class="aside-common-box-bottom" data-v-d487ed78><div class="aside-common-box-content aside-box-fold" data-v-d487ed78><ul data-v-d487ed78><li data-v-d487ed78><div class="interest-area-main" data-v-d487ed78><div class="interest-area-name" data-v-d487ed78>#后端</div> <!----></div> <div class="interest-area-sub" data-v-d487ed78><span data-v-d487ed78>#MySQL</span><span data-v-d487ed78>#Spring Boot</span><span data-v-d487ed78>#Java</span><span data-v-d487ed78>#C/C++</span><span data-v-d487ed78>#Spring</span><span data-v-d487ed78>#Redis</span><span data-v-d487ed78>#Linux</span></div></li></ul></div> <!----></div></div> <div class="user-special-column user-profile-aside-common-box" data-v-d487ed78><div class="aside-common-box-head" data-v-d487ed78>TA的专栏</div> <div class="aside-common-box-bottom" data-v-d487ed78><div class="aside-common-box-content aside-box-fold" data-v-d487ed78><ul data-v-d487ed78><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_10833947.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918135101160.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="问题解决" data-v-d487ed78>问题解决</span> <!----></a> <div class="special-column-num" data-v-d487ed78>1篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_10113594.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140129601.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="log" data-v-d487ed78>log</span> <!----></a> <div class="special-column-num" data-v-d487ed78>1篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_6641344.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140129601.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="编程题" data-v-d487ed78>编程题</span> <!----></a> <div class="special-column-num" data-v-d487ed78>4篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_6645815.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140129601.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="知识点" data-v-d487ed78>知识点</span> <!----></a> <div class="special-column-num" data-v-d487ed78>10篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_6818824.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140129601.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="Linux" data-v-d487ed78>Linux</span> <!----></a> <div class="special-column-num" data-v-d487ed78>16篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_6990424.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140158853.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="c++" data-v-d487ed78>c++</span> <!----></a> <div class="special-column-num" data-v-d487ed78>24篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_7296458.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140158853.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="排序" data-v-d487ed78>排序</span> <!----></a> <div class="special-column-num" data-v-d487ed78>6篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_7427001.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140158853.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="面试题" data-v-d487ed78>面试题</span> <!----></a> <div class="special-column-num" data-v-d487ed78>18篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_7506406.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140129601.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="网络" data-v-d487ed78>网络</span> <!----></a> <div class="special-column-num" data-v-d487ed78>1篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_7533766.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190927151101105.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="数据结构" data-v-d487ed78>数据结构</span> <!----></a> <div class="special-column-num" data-v-d487ed78>1篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_7569473.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140012416.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="MySQL" data-v-d487ed78>MySQL</span> <!----></a> <div class="special-column-num" data-v-d487ed78>4篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_7782201.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190927151026427.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="leetcode" data-v-d487ed78>leetcode</span> <!----></a> <div class="special-column-num" data-v-d487ed78>16篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_7885291.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190927151053287.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="软件测试" data-v-d487ed78>软件测试</span> <!----></a> <div class="special-column-num" data-v-d487ed78>3篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_7919827.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140037908.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="C++11" data-v-d487ed78>C++11</span> <!----></a> <div class="special-column-num" data-v-d487ed78>2篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_8030695.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190927151117521.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="操作系统" data-v-d487ed78>操作系统</span> <!----></a> <div class="special-column-num" data-v-d487ed78>1篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_8428639.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140129601.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="git" data-v-d487ed78>git</span> <!----></a> <div class="special-column-num" data-v-d487ed78>1篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_8523367.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190927151026427.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="Java" data-v-d487ed78>Java</span> <!----></a> <div class="special-column-num" data-v-d487ed78>2篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_8872735.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190927151043371.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="spring" data-v-d487ed78>spring</span> <!----></a> <div class="special-column-num" data-v-d487ed78>2篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_8987896.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/2019092715111047.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="ASP.NET" data-v-d487ed78>ASP.NET</span> <!----></a> <div class="special-column-num" data-v-d487ed78>1篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_9175619.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140129601.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="环境配置" data-v-d487ed78>环境配置</span> <!----></a> <div class="special-column-num" data-v-d487ed78>4篇</div></li><li data-v-d487ed78><a href="https://blog.csdn.net/qiana_/category_9186806.html" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" data-report-query="spm=3001.5482" class="special-column-name" data-v-d487ed78><img src="https://img-blog.csdnimg.cn/20190918140145169.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt data-v-d487ed78> <span title="工具常见问题" data-v-d487ed78>工具常见问题</span> <!----></a> <div class="special-column-num" data-v-d487ed78>1篇</div></li></ul></div> <button data-report-click="{&quot;spm&quot;:&quot;3001.5482&quot;}" class="aside-common-box-bottom-btn" data-v-d487ed78>展开<i class="el-icon-arrow-down" data-v-d487ed78></i></button></div></div> <!----></div></div> <div class="user-profile-body-right" data-v-3f0fdf46><div class="navList-box" data-v-bb5f5e3e data-v-3f0fdf46><div class="navList" data-v-bb5f5e3e><ul data-v-bb5f5e3e><li class="active" data-v-bb5f5e3e><!---->最近<span class="nav-li-num" data-v-bb5f5e3e></span></li><li data-v-bb5f5e3e><!---->文章<span class="nav-li-num" data-v-bb5f5e3e></span></li><li data-v-bb5f5e3e><!---->资源<span class="nav-li-num" data-v-bb5f5e3e></span></li><li data-v-bb5f5e3e><!---->问答<span class="nav-li-num" data-v-bb5f5e3e></span></li><li data-v-bb5f5e3e><!---->课程<span class="nav-li-num" data-v-bb5f5e3e></span></li><li data-v-bb5f5e3e><!---->帖子<span class="nav-li-num" data-v-bb5f5e3e></span></li><li data-v-bb5f5e3e><!---->收藏<span class="nav-li-num" data-v-bb5f5e3e></span></li><li data-v-bb5f5e3e><!---->关注/订阅<span class="nav-li-num" data-v-bb5f5e3e></span></li></ul> <div class="search-input" data-v-bb5f5e3e><input id="searchInput" type="text" placeholder="搜TA的内容" value="" data-v-bb5f5e3e> <div class="search-btn" data-v-bb5f5e3e><img src="https://img-home.csdnimg.cn/images/20210127052220.png" alt class="search-img" data-v-bb5f5e3e> <img src="https://img-home.csdnimg.cn/images/20210127052218.png" alt class="search-hover-img" data-v-bb5f5e3e></div></div> <div class="m-search-input" data-v-bb5f5e3e><input id="mSearchInput" type="text" placeholder="搜TA的内容" value="" data-v-bb5f5e3e> <div class="m-search-btn" data-v-bb5f5e3e><img src="https://img-home.csdnimg.cn/images/20210127052220.png" alt class="m-search-img" data-v-bb5f5e3e> <img src="https://img-home.csdnimg.cn/images/20210127052218.png" alt class="m-search-hover-img" data-v-bb5f5e3e></div></div></div> <div data-v-bb5f5e3e><div data-v-bb5f5e3e><div data-v-0db42936 data-v-bb5f5e3e><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/114680199" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>一个接口有多个实现类时，@Resource注入失败问题</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>问题描述接口：ExecuteServicepublic interface ExecuteService {    void doExecute(Context context);    void suspendTest(String taskId);}实现类1：UIExecuteServiceImpl@Servicepublic class UIExecuteServiceImpl implements ExecuteService {    @Resource    publ</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>80<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 2 月前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/114106477" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>vscode的vim插件不能使用ctrl-c问题</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>vscode更新后，发现和vim的使用一样了，应该是自动安装了vim插件，按i之后才可以使用。输入时发现，ctrl+c,ctrl+v使用不了了，以下是解决发方法：（1）方法一：卸载vim插件（2）方法二：打开File-&gt;Preferences-&gt;settings，搜索ctrl，找到Vim:Use Ctrl Keys，去掉前面的勾。但是这种方式将vim的ctrl功能都禁掉了。（3）方法三：搜索vim.handleKeys，打开settings.json文件.</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>82<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 月前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/107090624" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>win下配置jdk环境变量</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1. 配置JAVA_HOME：D:\Program Files\Java\jdk1.8.0_1912. 配置CLASSPATH：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar3. 配置Path：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin注意：在Windows7中可以这样配置，在win10中这么配置可能会出现（'javac' 不是内部或外部命令，也不是可运行的程序 或批处理文件）这样的错误。解决：这么写，不用</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>51<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 10 月前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/107090564" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>SwitchyOmega安装时的“.crx程序包无效”问题</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.什么是SwitchyOmega？SwitchyOmega是一款Chrome上的代理扩展程序，可用于翻墙。2.如何安装：https://blog.csdn.net/Qiana_/article/details/1070902463.在chrome://extensions/，打开开发者模式，将SwitchyOmega_Chromium.crx拖入其中，会出现“.crx程序包无效”。解决方法：（1）进入文件夹，修改扩展名为.zip或.rar（2）...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1501<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>2<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 10 月前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/107090246" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>SwitchyOmega的安装与配置</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.什么是SwitchyOmega？SwitchyOmega是一款Chrome上的代理扩展程序，可用于翻墙。2.如何下载：（1）谷歌应用商店下载：下载就需要翻墙╮(╯▽╰)╭（2）git下载地址：https://github.com/FelisCatus/SwitchyOmega/releases下载.crx结尾的扩展程序3.安装与配置（1）安装：在地址栏输入chrome://extensions 回车直接把下载好的 .crx 压缩包拖放到扩展程序管理（...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>3375<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 10 月前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/106812886" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>本地debug时出现:log4j:WARN No appenders could be found for logger</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>将代码发布到远程服务器时，可以正常运行，本地debug时，在main函数中写了一段测试代码，debug时出现：log4j:WARN No appenders could be found for logger (org.apache.hadoop.metrics2.li)解决方法：将下面方法插入到入口点Main方法处，是一个快速的系统配置。作用是与log4j.properties快速关联起来，自动快速地使用缺省Log4j环境。BasicConfigurator.configure(); //自.</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>96<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 10 月前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/104664675" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>如何使用idea远程debug</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>当需要调试远程服务器上的代码时，就需要进行远程debug。java远程调试功能可导致远程执行任意命令，默认情况下在生产禁止使用。如有需要在生产环境使用，则必须监听在127.0.0.1，避免被远程调用。（1）开启远程调试参数：    修改远程服务器的tomcat配置文件startenv.sh，添加如下内容：export JAVA_OPTS="-Xdebug -Xrunjdwp:...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>191<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 1 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/98076233" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>解决idea项目中Error:java: 无效的标记: -version</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>IDEA中提示：Warning:java: 源值1.5已过时, 将在未来所有发行版中删除https://blog.csdn.net/stripeybaby/article/details/80010734解决idea项目中Error:java: 无效的标记: -version问题https://www.cnblogs.com/lovezzb/p/10072854.html...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1318<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 2 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/97651388" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>IntelliJ IDEA配置</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>使用IntelliJ IDEA配置JDK：https://www.cnblogs.com/Knowledge-has-no-limit/p/7234360.html使用IntelliJ IDEA创建Maven项目：https://www.cnblogs.com/Knowledge-has-no-limit/p/7235026.html使用IntelliJ IDEA配置Tomcat：...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><!----> <div class="article-type article-type-zz" data-v-6fe2b6a7>转载</div> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>65<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 2 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/90640265" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>使用ASP.NET向MySQL数据库插入中文时乱码问题</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>问题描述：使用ASP.NET写了一个问卷调查系统，使用注册，创建问卷等向数据库插入中文字符时，mysql数据库中乱码了。但是从数据库从读取的中文字符可以正常的显示。在数据库中是可以正常的插入中文字符。------------------------------------------------------------------------------------------------...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1016<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 2 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/90639347" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>MySQL数据库插入中文失败问题</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>问题描述：创建数据库test字符集为utf8，表user字符集为utf8。插入中文字符时出现如下错误：ERROR 1366 (HY000): Incorrect string value: '\xCE\xE2\xD9\xBB' for column 'user_name' at row 1解决方法：方法一： 在mysql命令行下执行：SET NAMES GBK；（设置客户端字...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>2800<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>3<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 2 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/90454643" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>数据库中关于字符集的操作</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>一、查看字符集1.查看MySQL数据库的字符集和校验规则(1) show variables like 'character%';(2) show variables like 'collation%'; (3) status;mysql&gt; show variables like 'character%';+--------------------------+----...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>262<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 2 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/89386069" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>SpringMVC各层之间的区别及联系</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>项目分层实体层：bean、pojo、model等命名方式用途：和数据库的实体保持一致，还可以存放由数据库实体类而衍生的类，比如数据库实体类User中有一个字段experience，它的类型是Experience类，则Experience类也可存放于model文件夹中。数据传输层：dto层用途：用来进行数据的传输，是面向界面UI来进行设计的，是根据UI的需求来进行定义的。如果实...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>2559<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 2 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/84956394" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>IntelliJ idea的常用快捷键</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>IntelliJ新建一个类的快捷键是什么？选中文件夹，alt + insert如何快速打开一个类，比如，HashMap.java？ctrl + n，输入类名双击shift，输入类名如何进入到方法的定义处？鼠标放在类名处，按ctrl ，类名会变成超链接，点击即可如何回到进入该方法的上一处？ctrl+alt+ 左（Home）回到上一处ctrl+alt+ 右（End）...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>160<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/84451356" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>ubuntu下如何上传代码到码云</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>下面的指令都在命令行执行。一：安装与配置第一步：在ubuntu下安装git。以下实例在ubuntu下进行。确认你的系统是否安装了git，通过git指令进行查看。如果没有安装，就使用命令sudo apt-get install git来进行安装。Centos下git的安装和ubuntu不太一样，使用yum进行安装。 第二步：安装完成后进行git的配置。git config ...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>2035<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/82556330" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>死锁及其必要条件</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.简介在计算机系统中会出现很多一次只能由一个进程使用的资源，比如打印机，磁带机等，在多道程序设计中，若干进程要共享这类的资源，而且一个进程所需要的不止一个，这样，就会出现若干个进程竞争优先有限资源，由于推进顺序不当，就会曹成无限期的循环等待的局面，这种状态就是死锁。2.什么是死锁？所谓死锁，是指多个进程在运行过程中因竞争资源而需要循环等待对方释放资源的一种僵局。互相等待对方释放资源，...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>294<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/82227045" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>linux下的ctrl+z, ctrl+c, ctrl+d, ctrl+h的区别</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>在Linux下当我运行一个http服务器的时候，按下ctrl+z，发现进程退出了，再次运行的时候，发现端口被占用，于是就用kill -9 杀死这个进程或者在进程运行的时候按下ctrl+c退出进程。使用ctrl+c退出进程，就是真的退出了。那ctrl+z和ctrl+c都是中断命令，那它们有什么区别？Ctrl+z :当按下ctrl+z时，系统会发送SIGTSTP（20号信号）给前台进程组中的所...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1382<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/82149581" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>顺时针打印矩阵</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：对于一个矩阵，请设计一个算法从左上角(mat[0][0])开始，顺时针打印矩阵元素。给定int矩阵mat,以及它的维数nxm，请返回一个数组，数组中的元素为矩阵元素的顺时针输出。测试样例：[[1,2],[3,4]],2,2返回：[1,2,4,3]题目解析：将问题分解为一下几个步骤：1）从左到右打印矩阵2）从上到下打印矩阵3）从右到左打印矩阵...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>103<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/82083313" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>静态数据成员和静态成员函数</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>转载自：https://blog.csdn.net/computer_liuyun/article/details/29235111c++中的static静态数据成员和静态成员函数应该是让大家比较头疼的东西，好像也是找工作公司面试中常常问到的东西。我自己也深有体会，在学习c++的过程中，总感觉static很烦人，但是又是一个必须懂的东西，所以今天就对静态数据成员和静态成员函数坐下小结哈！一...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><!----> <div class="article-type article-type-zz" data-v-6fe2b6a7>转载</div> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>21070<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>14<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>97<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/82078183" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>理解POD数据类型</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.什么是POD？POD全称Plain Old Data。字面意思，普通的，旧的数据类型。通俗的讲，一个类或结构体通过二进制拷贝后还能保持其数据不变，那么它就是一个POD类型。2.C++11中的定义在维基百科中有：C ++中的普通旧数据结构是一个聚合类，它只包含PDS作为成员，没有用户定义的析构函数，没有用户定义的复制赋值运算符，也没有指向成员类型的非静态成员。被动数据结构（PDS...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1357<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>2<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81982574" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>数据库和表的基本操作</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.什么是数据库：高效的存储和处理数据的介质（介质有：磁盘和内存）文件保存数据的缺点：文件的安全性问题	文件不利于查询和对数据的管理	文件不利于存放海量数据	文件在程序中控制不方便2.连接数据库：在Linux下要使用mysql数据库，首先要开启mysqld服务（mysqld服务是数据库的服务器端）：[root@localhost http]$ service mysq...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>159<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81951392" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>测试用例的基本介绍</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.什么是测试用例？测试用列（Test Case）是为了实施测试二向被测试的系统提供的一组集合，这组集合包含：测试环境、操作步骤、测试数据、预期结果等要素。2.测试用例的要素测试用例的标题、测试思路、预设条件、步骤、预期输出一个好的测试用例是一个不熟悉业务的人也能依据用例来很快的进行测试。评价测试用例的标准：用例表达清楚，无二义性用例可操作性强永猎的输入与输出明确...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>7811<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>5<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>5<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81939921" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>TCP连接建立与释放（三次握手、四次挥手）</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>TCP协议的工作原理：TCP连接建立、报文传输、TCP连接释放。1.TCP连接建立：三次握手（1）最初客户端TCP进程是处于“CLOSE”（关闭）状态。当客户端准备发起一次TCP连接，进入“SYN-SEND”（准备发送）状态时，它会向处于“LISTEN”（收听）状态的服务器端TCP进程发送第一个控制位SYN=1的“连接建立请求报文”。“连接建立请求报文”是不携带任何数据字段的，但是...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>713<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81841513" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>XXXX is not in the sudoers file. This incident will be reported解决方法</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>XXXX is not in the sudoers file.  This incident will be reported解决方法假设你用的是Red Hat系列（包括Fedora和CentOS）的Linux系统。当你执行sudo命令时可能会提示“某某用户 is not in the sudoers file.  This incident will be reported.”解决方法:...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><!----> <div class="article-type article-type-zz" data-v-6fe2b6a7>转载</div> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>756<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81839006" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>解决类似 /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found 的问题</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>源码编译升级安装了gcc后，编译程序或运行其它程序时，有时会出现类似/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found的问题。这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库导致的，将gcc最新版本的动态库替换系统中老版本的动态库即可解决。 1. 问题原因分析为了安装最新版本的Node.js（最新版本...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><!----> <div class="article-type article-type-zz" data-v-6fe2b6a7>转载</div> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>579<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81811465" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>Centos6.5 安装boost库</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>要使用boost中的有些内容，在网上找了一下，有些安装很复杂。最终找到了一个很简单的安装boost的方法。环境：Centos6.5   gcc 4.8.2  g++ 4.8.2yum install boostyum install boost-develyum install boost-doc测试一下：代码来自：https://blog.csdn.net/qiuyouj...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1037<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81805733" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode: construct-binary-tree-from-inorder-and-postorder-traversal  使用中序和后序遍历重建二叉树</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given inorder and postorder traversal of a tree, construct the binary tree.Note:You may assume that duplicates do not exist in the tree.题目解析： //题目：construct-binary-tree-from-inorder-a...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>138<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81805516" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode : same-tree：判断是不是相同的树</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given two binary trees, write a function to check if they are equal or not.Two binary trees are considered equal if they are structurally identical and the nodes have the same value.题目解析：...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>127<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81782729" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode: binary-tree-postorder-traversal:后序遍历二叉树</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a binary tree, return the postorder traversal of its nodes' values.For example:Given binary tree{1,#,2,3},   1    \     2    /   3return[3,2,1].Note: Recursive solution is tr...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>113<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><!----> <!----> <!----> <!----> <!----> <div class="resources-list-box" data-v-1cf431f8 data-v-0db42936><a href="https://download.csdn.net/download/qiana_/10611042" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-1cf431f8><h4 data-v-1cf431f8>二分法解非线性方程</h4> <div class="resources-list-content" data-v-1cf431f8>二分法解非线性方程，输入区间，可以误差限，可以求得非线性方程的根</div> <div class="resources-list-footer" data-v-1cf431f8><div class="resources-list-footer-left" data-v-1cf431f8><div class="res-download" data-v-1cf431f8><img src="https://img-home.csdnimg.cn/images/20210127052054.png" alt data-v-1cf431f8> <div class="res-download-text" data-v-1cf431f8>cpp</div></div></div> <div class="resources-list-footer-right" data-v-1cf431f8><span data-v-1cf431f8>发布</span><span class="message-type" data-v-1cf431f8>资源</span><span data-v-1cf431f8>于 3 年前</span></div></div></a></div></div><div data-v-0db42936><!----> <!----> <!----> <!----> <!----> <div class="resources-list-box" data-v-1cf431f8 data-v-0db42936><a href="https://download.csdn.net/download/qiana_/10611018" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-1cf431f8><h4 data-v-1cf431f8>软件测试面试突击</h4> <div class="resources-list-content" data-v-1cf431f8>该书讲了软件测试的基础知识，黑盒测试，白盒测试，测试用例，系统测试，单元测试，测试工程师的面试题等内容。</div> <div class="resources-list-footer" data-v-1cf431f8><div class="resources-list-footer-left" data-v-1cf431f8><div class="res-download" data-v-1cf431f8><img src="https://img-home.csdnimg.cn/images/20210127052054.png" alt data-v-1cf431f8> <div class="res-download-text" data-v-1cf431f8>pdf</div></div></div> <div class="resources-list-footer-right" data-v-1cf431f8><span data-v-1cf431f8>发布</span><span class="message-type" data-v-1cf431f8>资源</span><span data-v-1cf431f8>于 3 年前</span></div></div></a></div></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81774444" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>atoi和itoa的模拟实现</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.atoi函数：函数原型：int atoi (const char * str);该函数的功能是将字符串转化为整型。分以下几种情况：1）如果该字符串的最开始是 -，并且后面加的是数字，那么转化的整数是负整数。2）如果该字符串的最开始是+ 或者是数字，那么转化的是正整数。3）如果最开始是-/+ 加其他字符，就是不合法的，直接返回0.4）考虑溢出，正溢出和负溢出。模...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>142<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81737821" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>C语言中的常见字符串操作函数</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>以下函数的头文件位于#include&amp;lt;string.h&amp;gt;1.strcat函数：函数原型：char * strcat ( char * destination, const char * source );该函数是字符串拼接函数。将源字符串拼接至目标字符串的结尾处。要覆盖目标字符串中的'\0'。source和destination的空间不能重叠，而且destination...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>163<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81710657" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>序列化二叉树</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：请实现两个函数，分别用来序列化和反序列化二叉树。题目解析：序列化：将一颗二叉树序列化，以前序遍历的顺序序列化，从根节点开始，将节点的值转换为字符，存入一个字符串中，每存一个值，再加上一个',' ，当遍历到空节点的时候，加上'#'。反序列化：将一个字符串还原为一个二叉树，将字符0-9转换为字符 （ch - '0'）。转换为整型后，创建一个节点其值为该整型。再递归的调用左子树...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>77<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81710551" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode:  binary-tree-preorder-traversal</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a binary tree, return the preorder traversal of its nodes' values.For example:Given binary tree{1,#,2,3},   1    \     2    /   3 return[1,2,3].Note: Recursive solution i...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>109<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81699786" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>对称的二叉树</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。题目解析：思路：从根节点开始，判断它的左子树和右子树是否相等，它们的值是否相等。再递归的判断左子树的左子树和右子树的右子树是否相等，左子树的右子树和右子树的左子树是否相等。AC代码：/*struct TreeNode {    int val;  ...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>116<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81661697" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>二叉搜索树的后序遍历序列</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。题目解析：对于后序遍历的序列来说，最后一个值应该是根节点。二叉搜索树的左子树都比根节点小，右子树都比根节点大。因此，对于后序序列，倒着往前找，比最后一个节点大的是二叉树的右子树的节点，比最后一个节点小的是二叉树的左子树的节点。如果在本该是右...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>112<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81639302" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>二叉树的下一个节点</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针next。题目解析：给定一棵二叉查找树，注意参数部分传的是这个节点，而不是二叉树的根节点。查找中序遍历的下一个节点，如果该结点是最大的，则返回 NULL。其他的情况有以下的图解：AC代码：/*struct TreeLinkNode...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>335<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81639227" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>重建二叉树</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。题目解析：通过前序遍历的序列和中序遍历的序列，构建出二叉树，从前序遍历的特点可以看出，其序列的第一个节点是根节点，先是遍历完左子树，再进行遍历...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>142<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81624686" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>链接属性</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>C语言中的链接属性决定如何处理在不同文件中出现的标识符，标识符的作用域和它的链接属性有关。链接属性的分类：外部链接属性：全局标识符具有链接属性（全局变量）；使用关键字extern声明的变量或函数，可以在其它的源文件中使用；外部链接属性就意味着，一个标识符，不仅可以在当前的源文件中使用，还可以在程序的其他文件中使用。test.cint g_val = 10;  //具有...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>946<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81584012" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>二叉树的深度</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。题目解析：采用递归遍历：1）如只有1个节点，深度就为12）当前结点的深度就是它的左子树和右子树中深度大的一个再加1./*struct TreeNode {	int val;	struct TreeNode *left;	stru...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>103<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81583294" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>二叉树的镜像</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树     	    8    	   /  \    	  6   10    	 / \  / \    	5  7 9 11    	镜像二叉树    	    8    	   /  \    	  10   6    	 / \  / \    	11 9 7  ...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>388<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81570697" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>STL之Stringstream字符串流使用总结</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>转载自：https://blog.csdn.net/fanyun_01/article/details/66967710如果你已习惯了&amp;lt;stdio.h&amp;gt;风格的转换，也许你首先会问：为什么要花额外的精力来学习基于&amp;lt;sstream&amp;gt;的类型 转换呢？也许对下面一个简单的例子的回顾能够说服你。假设你想用sprintf()函数将一个变量从int类型转换到字符串类型。为了正确地完成...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><!----> <div class="article-type article-type-zz" data-v-6fe2b6a7>转载</div> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>109<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81539619" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>把二叉树打印成多行</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。题目解析：采用层序遍历的思想。将节点push进队列中，当队列不为空时，增加两个变量，一个用来计数，一个用来获取当前队列中的节点个数。当计数小于总数时，说明这些节点在一层中，将这些节点push_back进vector1中。再遍历当前结点的左子树和右子树，将vector1 push_back 进vector2中。队列...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>149<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81513143" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>C++11新特性1</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>C++11中增加了一些新的特性，需要在vs2011（或Linux g++4.8，编译时需要加-std=c++11）之后的版本中才可进行语法解析。1、nullptr常量nullptr的出现是为了替换NULL，nullptr是一种特殊类型的字面值，可以被转换成任意的其他类型的指针。传统的C++，NULL和0的意义是一样的。有些编译器会将NULL定义为((void*)0)，有的编译器会将NU...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>81<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81490361" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode: remove-nth-node-from-end-of-list：删除倒数第n个节点</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a linked list, remove the n th node from the end of list and return its head.For example,   Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.   After removing the second nod...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>84<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81488907" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode: rotate-list:旋转链表</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a list, rotate the list to the right by k places, where k is non-negative.For example:Given1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULLand k =2,return4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL.题目解析：...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>82<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81487772" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode : add-two-numbers</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>59<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81487319" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>用两个栈实现队列</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>用两个栈实现队列：栈 是先进的后出来，队列是先进的先出来。入队列：直接push进stack1出队列：如果两个队列都为空就直接返回。如果stack2为空，就将stack1中的元素push进Stack2中，再对Stack2进行pop，此时就相当于pop了队列（入栈的一个元素）。如果stack2不为空，就直接pop stack2中的元素。AC代码：class Solution{...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>82<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81486751" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>公交卡的测试用例</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>下面以思维导图的方式写出公交卡的测试用例：(*^▽^*)</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1069<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81450177" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>LeetCode：reorder-list：重排链表</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a singly linked list L: L 0→L 1→…→L n-1→L n,reorder it to: L 0→L n →L 1→L n-1→L 2→L n-2→…You must do this in-place without altering the nodes' values.For example,Given{1,2,3,4}, reo...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>121<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81450073" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>LeetCode：partition-list:对链表进行分区</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in ea...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>113<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81449793" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode: convert-sorted-list-to-binary-search-tree：将排序的链表转换成二叉搜索树</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.题目解析：通过快慢指针找到链表的中点，作为二叉搜素树的根节点。以中点为界，将链表分为两部分，不包含中点，分别对两部分链表递归调用原函数，最后连上根节点的左右子树...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>69<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81437536" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>LeetCode：sort list</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Sort a linked list in O(n log n) time using constant space complexity.题目解析：使用O(nlogn)的算法排序数组。O(nlogn)的排序算法有快速排序，归并排序，堆排序。这里使用归并排序。归并排序的一般步骤为：（1）将待排序链表，取中点，一分为二；（2）递归地对左半部分进行归并排序；（3）...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>44<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81356119" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>二叉搜索树与双向链表</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。题目解析：二叉搜索树使用中序遍历就是有序的，将二叉树转换成双向链表，就是要改变指针的指向。比如，作左子树的right = 根，根的left = 左子树，根的right = 右子树 ，右子树的left = 根。AC代码：/*struct TreeN...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>46<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81355557" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>求两个链表的第一个公共结点</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：输入两个链表，找出它们的第一个公共结点。题目分析：两个链表要有公共结点，就必须要有公共的尾部，从最后一个节点开始，最后一个不相等的节点就是第一个公共的节点。方法一：使用栈来实现：将两个链表分别push进两个栈中，然后不断的pop，用一个FirCom来记录相等的节点，pop一个值，就更新一下FirCom，最后一次记录的FirCom值就是第一个公共的节点。AC代码：...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>59<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81333978" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>复杂链表的复制</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）题目解析：复杂链表有一个next指针，指向下一个节点，一个random指针，可以指向任意的节点。复杂链表的复制分为三步：1.复制原链表，在原链表的每个节点后...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>54<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81332332" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>LeetCode：triangle</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.For example, given the following triangle[     [2],    [3,4],...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>66<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81332008" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>剑指offer：合并两个排序的链表</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>解题思路：两个链表是排序好的，比较两个链表的头结点的值，小的那个结点做新链表的头结点。依次比较各个节点的值，有序的链入到新链表中。其中一个链表已经比较完了，将另一个链表剩下的结点都链入到新链表中。在线AC：/*struct ListNode {	int val;	struct ListNode *next;	ListNode(int x) :			val(x), next(NU...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>52<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81281289" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>智能指针</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>本文主要讨论C++标准库中的auto_ptr，boost库中的scoped_ptr, shared_ptr, weak_ptr1.什么是RAII       RAII全称为Resourse Acquisition Is Initialization，意为资源分配即初始化，定义一个类来封装资源的分配和释放，在构造函数完成资源的分配和初始化，在析构函数完成自愿的清理，可以保证资源的正确初始化和...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>61<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81262668" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>软件测试的基本介绍</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.什么是软件测试？软件测试是为了验证软件功能是否满足用户的需求。它有两个方面的含义：一、找出软件存在的bug        二、证明软件不存在错误的过程，即验证软件是正确的。软件测试的定义随着发展而不断扩展，但是不可否认的是软件测试最基本的活动就是找bug。而不同的定义只是说明了测试的目的以及如何来衡量测试是否成功。2.软件测试的发展过程 软件调试：软件测试是伴随着软件的...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1198<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81239869" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>使用C语言判断一个机器是大端机还是小端机</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.什么是大端，什么是小端？大端：数据的高位字节存放在低地址内，数据的低位字节存放在高地址内。小端：数据的高位字节存放在高地址内，数据的低位字节存放在低地址内。一个整型是4个字节，如：0x1a2b3c4d。电脑读取内存数据时，是从低位地址到高位地址进行读取（从左到右）。在小端机器中从低地址到高地址的存放方式为：0x4d,0x3c,0x2b,0x1a；(低地址存低位)在大端机器中...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>4339<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>3<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>5<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81083449" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode: sort-colors  颜色排序</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>130<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/81048708" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode : marge-intervals:合并区间</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a collection of intervals, merge all overlapping intervals.   For example, Given[1,3],[2,6],[8,10],[15,18],  return[1,6],[8,10],[15,18].解题思路：    题目的意思是：一个vector中存着Interval对象，Interval是一个结构体，...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>91<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80980456" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>leetcode:  restore-ip-address(恢复ip地址)</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a string containing only digits, restore it by returning all possible valid IP address combinations.For example:Given &quot;25525511135&quot;,return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does ...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>352<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80937904" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>Leetcode:  search-for-a-range</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a sorted array of integers, find the starting and ending  position of a given target value.   Your algorithm's runtime complexity must be in the order of  O(log n).   If the target is not f...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>104<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80937476" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>Leetcode: search-insert-position</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：Given a sorted array and a target value, return the index if the  target is found. If not, return the index where it would be if it were  inserted in order.   You may assume no duplicates in the ...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>149<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80544042" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>连续子数组的最大和</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：输入一个整型数组，数组理由整数也有负数。数组中有一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。输入：3 -1 1 2  （3为输入的个数，后面3个位数组中的元素{-1,1,2}）输出：3   （1+2=3）输入：8 1 -2 3 10 -4  7 2 -5    （数组为{1,-2,3,10,-4,7,2,-5}）输出：18   （3,10，-4...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>104<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80499398" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>面试题：二维数组中的查找</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。例如在如下的数组中查找数字7的过程如下：数组： 1    2     8      9           2    4     9     12           4    7    10    13          ...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>135<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80467863" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>数组中出现次数超过一半的数字</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}，由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2.这道题出自《剑指offer》中的面试题。一种简单的算法是，先对数组进行排序，排序之后位于数组中间的数字就一定是出现次数超过数组长度一半的数字。排序算法的时间复杂度为O(nlogn)。下面是两个O(N)...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>113<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80367272" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>Linux 信号signal</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1. 信号的基本概念    联系现实生活中的信号，我们可以理解为：Linux中的signal其实就是一种标志，操作系统知道这个标志代表着什么含义，以及知道遇见这个标志它应该采取怎样的动作。（如红灯信号，你知道红灯信号代表着不能通过马路，而你采取的动作就是等待）1.1 信号的分类：使用kill -l : 可以查看系统定义的信号列表。总共有62种信号。1-31号信号称为普通信号，34-64号信号称为实...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>81<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80196557" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>进程间通信---信号量</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>信号量的有关概念：信号量：主要用于同步与互斥。为了防止出现因多个进程访问临界资源而引发的一系列问题，信号量可以提供这样一种访问机制，在任一时刻只能有一个执行线程访问代码的临界区域，也就是说信号量是用来协调进程对临界资源的访问。信号量的操作：信号量是一种特殊的变量，对信号量的访问必须是原子操作，信号量的操作只有两种：P操作（-1，申请资源）和V操作（+1，释放资源）。最简单的信号量只有两种取值0和1...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>104<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80231199" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>jsoncpp的安装与配置</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>网上有和很多的文章介绍jsoncpp的安装，本人走了不少歧路，在此分享一下自己的安装步骤。安装jsoncpp前必须安装scons。1.scons下载地址：http://sourceforge.net/projects/scons/files/scons/2.1.0/scons-2.1.0.tar.gz/download2.jsoncpp下载地址：http://sourceforge.net/pro...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>1391<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>3<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/80150565" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>进程间通信---共享内存（Shared Memory）</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>共享内存的概念：共享内存是进程间通信（IPC）中最简单的方式之一，也是最快的IPC形式。共享内存允许两个或多个进程访问同一块内存。当一个进程改变了这块内存中的内容的时候，其他进程就可以察觉到这种更改。一旦这样的内存映射到共享它的进程的地址空间，这些进程间的数据传递将不再涉及到内核，即进程不再通过执行进入内核的系统调用来传递数据，而是这些进程通过共享内存来传递数据。共享内存的原理：共享内存就是有一块...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>946<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>4<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79995676" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>指针和引用</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1. 指针：指针是一个变量（对象），它的内容是一个地址，指向内存的一个存储单元。通过修饰符“*”来表示，解引用 *p 来表示指针p所指对象的值。指针在逻辑上是独立的，可以改变，比如指针变量的值和指针变量指向的内存的值都是可以改变。不同类型的指针可以指向特定类型的对象，即指针的类型要与所指向的对象的类型一致。可通过指针的指向来改变所指向的对象的值。const指针：常量指针const int *p;...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>68<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79778657" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>进程间通信---管道和消息队列</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>进程间通信的目的：数据传输：一个进程需要将它的数据发送给另一个进程资源共享：对个进程之间共享同样的资源通知事件：一个进程需要向另一个或一组进程发送消息，通知它们发生了什么事件进程控制：有些进程希望完全控制另一个进程的执行（如：Debug进程）进程间通信的发展：管道：System V进程间通信：POSIX进程间通信：进程间通信的分类：管道：我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>342<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79978075" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>std::strcpy、strncpy、memset、memcpy用法</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>转载自：https://blog.csdn.net/jin13277480598/article/details/535422091. std::strcpy 功能：将一个字符串复制到另一个字符串（如果字符串重叠，该行为是未定义）； 定义于头文件 &amp;lt;cstring&amp;gt; char *strcpy( char *dest, const char *src );参数： dest    :指向复...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><!----> <div class="article-type article-type-zz" data-v-6fe2b6a7>转载</div> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>169<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79951106" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>memcpy和memmove</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>memcpy功能：内存拷贝函数，从数据源拷贝num个字节的数据到目标数组函数原型：void * memcpy ( void * destination, const void * source, size_t num );函数参数：destination：指向目标数组的指针source：指向数据源的指针num：要拷贝的字节数使用方法：#include&amp;lt;stdio.h&amp;gt;#include...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>460<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79908432" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>右值引用</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>右值引用是C++11提出的新概念，通过这些操作，可以降低拷贝带来的消耗。左值和右值左值一般位于赋值号的左边，指的是一个对象本身，或者是一个持久的值，可以被多次引用和使用。例如赋值的返回值、下标操作、解引用以及前置递增等。左值必须在内存中有实体。右值是一个短暂的值，代表对象的值，一般不可以引用，只在当前的表达式中有效。比如一个表达式的求值结果、函数返回值以及一个字面值等。（不一定是赋值号右边的值）右...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>155<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79930799" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>动态内存管理</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>内存：      内存又叫内存储器，在冯诺依曼体系结构中，外设不能和CPU直接进行数据交流，外设可以和内存进行输入和输出，内存可以和CPU（运算器和控制器）进行数据交流。程序运行是要加载到内存中才能执行，变量需要申请内存才能被执行。申请了资源（内存）就要释放资源，不进行释放，CPU占有量会越来越大，其他进程就申请不到资源，就会造成内存泄露，对于普通的电脑来说，最终的结果就是关机，但对于大型服务器来...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>258<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79919686" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>linux（centos）下安装boost库及使用</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>转载自：https://blog.csdn.net/timekeeperl/article/details/50622633一、安装       刚刚使用linux系统，对很多系统命令和操作方式还不是很熟悉。想装个boost库，在网上看了几篇教程根本没弄明白，终于，用三行命令解决了。      yum install boost      yum install boost-devel      ...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><!----> <div class="article-type article-type-zz" data-v-6fe2b6a7>转载</div> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>13732<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79839901" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>mysql报错Fatal error: Can't open and lock privilege tables: Table 'mysql.host' doesn't exist</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>参考自：https://blog.csdn.net/indexman/article/details/16980433今天在启动mysql时，没有启动成功，查看日志报错如下:1、查看报错信息如下:[root@localhost local]# cd  /var/log/mysqld.log | grep 'ERROR'[ERROR] Fatal error: Can't open and lock...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>3834<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79778483" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>进程的有关概念</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>什么是进程：进程是程序的一个执行实例，是系统进行资源分配和调度的一个基本单位。程序段、相关数据段和PCB三部分构成，又叫进程实体、进程映像。所谓创建进程，实质上是创建进程实体中的PCB，撤销进程，实质上是撤销进程的PCB。什么是PCB：为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须位置配置一个专门的数据结构，称为进程控制块（Process Control Block，PCB...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>170<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79672857" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>C++之位图</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.概念位图（bitset）是一种常用的数据结构，常用在给一个很大范围的数，判断其中的一个数是不是在其中。在索引、数据压缩方面有很大的应用。位图是用数组实现的，数组的每一个元素的每一个二进制位都表示一个数据，0表示该数据不存在，1表示该数据存在。2.C++库中bitset的使用3.bitset的简单实现当我们存放一个数据时的思路是：1）确定数据在哪个区间上，即_bitSet的第几个元素上，_bit...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>2018<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79552087" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>特殊的数据类型：socklen_t、uint32_t、pthread_t</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>在编程的时候，发现了一些不知道什么类型的数据类型，于是整理了一下。1.socklen_t是一种数据类型，它其实和int差不多，在32位机下，size_t和int的长度相同，都是32 bits,但在64位机下，size_t（32bits）和int（64 bits）的长度是不一样的,socket编程中的accept函数的第三个参数的长度必须和int的长度相同。于是便有了socklen_t类型。int...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>2991<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>5<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79505245" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>编写代码，演示多个字符从两端移动，向中间汇聚。</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>就是有两个字符串数组。代码实现：#include&amp;lt;Windows.h&amp;gt;int main(){	char arr1[] = &quot;###################&quot;;	char arr2[] = &quot;welcome to world!!!&quot;;	int left = 0;	int right = strlen(arr1)-1;	printf(&quot;%s<br/>&quot;,arr1);	wh...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>100<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79505109" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>逻辑题：确定5位运动员的比赛名次。</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7> 题目：5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果A选手说：B第一，我第三。B选手说：我第二，E第四。C选手说：我第一，D第二。D选手说：C最后，我第三。E选手说：我第四，A第一。比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。思路：A,B,C,D,E的比赛名次都有可能是第一名到第四名。所以用5个for循环，在for循环里，进行if条件判断，输出比赛名次。void Rank(...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>521<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79454126" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>写一个函数返回参数二进制中1的个数</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>问题：写一个函数返回参数二进制中1的个数。例如：10的二进制位为00000000 00000000 00000000 00001010 ，其中1的个数有2个。解法一：10的二进制：1010    5的二进制：0101      2的二进制：0010    1的二进制：0001     0的二进制：0000value/2 相当于右移一位，当value==0时，跳出循环。当value%2 == 1时，...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>162<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79363491" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>归并排序</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>什么是归并排序？             归并排序采用了分治法（divide-and-conquer），将原问题分解为一些规模较小的相似子问题，然后递归解决这些子问题，最后合并其结果作为原问题的解。归并排序的算法通常用递归实现，将带排序的区间[a,b]二分，再二分，直至每个小区间只有一个元素，则每个小区间都是有序的，将小区间两两有序合并，直至成为一个区间，此时该区间是有序的。完成归并排序主要有两个...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>220<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79361823" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>快速排序的非递归实现</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>快速排序的非递归主要使用栈来实现。void QuickSortNonR(int* a,int left,int right){	stack&amp;lt;int&amp;gt; s;	s.push(right);	s.push(left);	while(!s.empty())	{		int begin = s.top();		s.pop();		int end = s.top();		s.p...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>199<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79176936" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>找出数组中出现次数超过一半的数字</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>题目：一个数组中有一个数字的次数超过了数组的一半，求出这个字符。如：int a[] = {2,3,2,2,2,2,2,5,4,1,2,3}，求出超过一半的数字是2。解法一：数组中有一个数字出现的次数超过了数组长度的一半，如果把数组排序，排序之后位于数组中间的数字一定是出现次数超过数组长度一半的数字。排序算法可以使用sort(快排)，它的时间复杂度为O(n*logn)。例如：{2,5,7,2,2</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>3058<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>2<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79164060" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>交换排序：冒泡排序和快速排序</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>交换排序分为冒泡排序和快速排序。冒泡排序：    它是一种比较简单的排序方法，相邻两个元素两两比较，如果后一个比前一个大，就交换，每趟排序都可以将大的元素“浮”到顶端。外层循环循环n-1次，相当于排好了最大的n-1个元素的位置，则最后一个元素的位置就确定了。内层循环循环n-i次，两两交换，第一次排出最大元素在a[n-1]处；第二次循环n-1次，最大元素在a[n-2]处。时间复杂度：...</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>146<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79121476" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>堆排序</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.什么是堆？   堆其实是一颗完全二叉树，堆分为大堆和小堆。所谓大堆，就是父节点的值大于等于左右孩子结点的值，即a[i] &gt;= a[2*i+1] && a[i] &gt;= a[2*i+2]。所谓小堆，就是父节点的值小于等于左右孩子结点的值，即a[i] 堆排序是用堆这种数据结构设计的一种排序算法，是选择排序的一种。利用数组的特点快速定位到指定索引的元素。2.算法思想首先建一个大堆，堆顶</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>101<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/79120854" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>选择排序的介绍</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>选择排序是一种简单直观的排序算法，最大的数和最小的数不断交换，一趟排序下来，会将最大的数放在最后一个位置，最小的数放在起始位置。第二趟排序选出次大和次小的数，依次类推。算法思想：第一趟：MAX是9，MIN是0，MIN和begin交换，begin处为最小的数，MAX和end交换，end处为最大的数。begin++，end--，同理，begin处为次小的数，end处为次大的数。当beg</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>136<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 3 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/78648720" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>makefile介绍</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>转自：http://blog.chinaunix.net/uid-403164-id-2407545.html转自：https://www.cnblogs.com/qiaozhoulin/p/4896326.html什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><!----> <div class="article-type article-type-zz" data-v-6fe2b6a7>转载</div> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>88<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 4 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/78573264" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>插入排序</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>插入排序  对一个已经有序的数据序列插入一个数。要求插入后此数据序列仍然有序。插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>593<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 4 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/78571202" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>Linux基本指令</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1.进入目录需要哪些权限。新建一个Experiment目录。 现在的目录user权限为可读（-r）、可写（-w）、可执行（-x）将读写执行权限去掉之后，我们发现进入不了目录了。给目录分别增加读、写、执行权限，我们发现在读权限、写权限、可读可写权限下进入不了目录，只有在可执行权限下才可以进入目录。总结：要进入一个目录必须要有可执行权限（</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>143<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 4 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/77509181" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>类和对象</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1：类和对象的相关概念 类（class/struct）是一种非基本的数据类型，包括数据（成员变量）和程序（成员函数），类的访问限定符有三种，私有(private)、保护(protected)、公有(public)，通过给予成员变量和成员函数不同的访问限定符，达到限定对象访问的目的。类的访问限定符体现了面向对象的封装性。 一个类并没有分配实际的内存空间来储存它，只有当一个类实例化对象的时候，才给它分</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>147<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>1<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 4 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/77483522" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>string之写时拷贝</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>写时拷贝又叫引用计数的浅拷贝，浅拷贝不同于深拷贝的既拷空间又拷数据，浅拷贝只是拷贝数据，每开辟一块空间，随之有一个计数器，当有多个对象指向该空间时，引用计数++，每销毁一个对象，引用计数–，当引用计数为1时，才真正的销毁这块空间。第一种实现：开辟一块空间的同时，再开辟一块空间存放引用计数。 //写时拷贝(第一种)class String{public:    String(char* st</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>193<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 4 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div><div data-v-0db42936><article class="blog-list-box" data-v-6fe2b6a7 data-v-0db42936><a href="https://blog.csdn.net/Qiana_/article/details/76691488" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.5501&quot;}" data-report-query="spm=3001.5501" data-v-6fe2b6a7><div class="blog-list-box-top" data-v-6fe2b6a7><h4 data-v-6fe2b6a7>智能指针</h4> <!----></div> <div class="blog-list-content" data-v-6fe2b6a7>1：智能指针的发展历史 &lt;1&gt;理解： 在动态内存分配中，为解决抛异常执行流跳转，导致内存泄漏的问题，产生了一个智能指针的类（smart pointer）,智能指针是基于RAII的设计思想（资源分配即初始化，资源的有效期与持有对象的生命期严格绑定），期待它能像指针一样，智能的管理指针所指向的动态资源的释放。  &lt;2&gt;开始是auto_ptr（C++98）：设计思想是管理权的转移，管理权在谁手上谁才有</div> <div class="blog-list-footer" data-v-6fe2b6a7><div class="blog-list-footer-left" data-v-6fe2b6a7><div class="article-type article-type-yc" data-v-6fe2b6a7>原创</div> <!----> <!----> <div class="view-num-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051656.png" alt data-v-6fe2b6a7> <span class="view-num" data-v-6fe2b6a7>145<span class="two-px" data-v-6fe2b6a7>阅读</span></span></div> <div class="comment-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127051933.png" alt data-v-6fe2b6a7> <span class="comment-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>评论</span></span></div> <div class="give-like-box" data-v-6fe2b6a7><img src="https://img-home.csdnimg.cn/images/20210127052104.png" alt data-v-6fe2b6a7> <span class="give-like-num" data-v-6fe2b6a7>0<span class="two-px" data-v-6fe2b6a7>点赞</span></span></div></div> <div class="blog-list-footer-right" data-v-6fe2b6a7><span data-v-6fe2b6a7>发布</span><span class="message-type" data-v-6fe2b6a7>博客</span><span data-v-6fe2b6a7>于 4 年前</span></div></div></a></article> <!----> <!----> <!----> <!----> <!----></div></div></div> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----></div> <!----> <!----></div></div></div></div></div></div></div></div></div></div> <div>
        <script type="text/javascript" src="https://g.csdnimg.cn/common/csdn-footer/csdn-footer.js" data-isfootertrack="false" defer></script>
      </div></div></div><script> window.__INITIAL_STATE__= {"csrf":"vAXHkfhh--uAfPcfXoRX5Sg-dMVWGxxA8CqY","origin":"http:\u002F\u002Fcms-user.internal.csdn.net","isMobile":false,"cookie":"uuid_tt_dd=10_36703830070-1620275049577-336237;","ip":"218.197.153.159","test":"cms-user.internal.csdn.net-undefined","pageData":{"page":{"pageId":121,"title":"用户主页","keywords":"用户主页","description":"用户主页","ext":{"guide":"1"}},"template":{"templateId":75,"templateComponentName":"user-profile","title":"用户主页","floorList":[{"floorId":485,"floorComponentName":"floor-user-profile","title":"","description":"","indexOrder":1,"componentList":[{"componentName":"baseInfo","componentDataId":"user-profile","componentConfigData":{},"relationType":3},{"componentName":"versionSwitchTips","componentDataId":"blog-user-version-switch","componentConfigData":{},"relationType":3}]}]},"data":{"baseInfo":{"basicModule":{"owner":false,"enterprise":false},"blogModule":{"userName":"Qiana_","level":0,"config":"\u003CConfig\u003E\u003CSHOWMODE\u003E0\u003C\u002FSHOWMODE\u003E\u003CNOTIFY\u003Enone\u003C\u002FNOTIFY\u003E\u003CPAGESIZE\u003E20\u003C\u002FPAGESIZE\u003E\u003C\u002FConfig\u003E","status":1,"flag":0,"viewCount":0,"blogId":5745335,"originalCount":0,"title":"Qiana_wq的博客","point":0,"skinId":1,"skin":"skin3-template","commentCount":0,"rank":0,"diggCount":0,"subTitle":"","repostCount":0,"translatedCount":0,"openReward":1,"rewardDescription":"","codeStyle":"atelier-sulphurpool-light","customCss":"","visitedTimes":0,"createdTime":"2016-10-27T07:06:28.000+0000"},"seoModule":{"title":"Qiana_wq的博客_Qiana_Wu_CSDN博客-c++,面试题,Linux领域博主","description":"Qiana_Wu擅长c++,面试题,Linux,等方面的知识,Qiana_Wu关注Linux,C\u002FC++,Java,MySQL,Redis,Spring,Spring Boot领域.","keywords":null,"landing":null,"jsonId":null},"userModule":{"avatar":"https:\u002F\u002Fprofile.csdnimg.cn\u002F8\u002FB\u002F6\u002F1_qiana_","username":"Qiana_","nickname":"Qiana_Wu","vip":false,"follow":false,"blogUrl":"https:\u002F\u002Fblog.csdn.net\u002FQiana_","imUrl":"https:\u002F\u002Fim.csdn.net\u002Fim\u002Fmain.html?userName=Qiana_","hasPersonal":false,"hasCompany":false,"hasEducation":false,"hasEmployee":false,"level":5,"levelIcon":"https:\u002F\u002Fcsdnimg.cn\u002Fidentity\u002Fblog5.png","introduction":"坚持不懈的编程","school":null,"company":null,"registrationTime":"2016-10-27","codeAge":{"icon":"https:\u002F\u002Fimg-home.csdnimg.cn\u002Fimages\u002F20210108035952.gif","background":"#C7E9FD","color":"#1E68D8","desc":"码龄5年"},"gender":2,"defaultBackgroundImg":"https:\u002F\u002Fimg-home.csdnimg.cn\u002Fimages\u002F20210120054229.jpg","hasShowcase":false},"companyModule":null,"achievementModule":{"originalCount":"104","viewCount":"103,113","rank":"49,354","fansCount":"45","achievementList":[{"icon":"https:\u002F\u002Fimg-home.csdnimg.cn\u002Fimages\u002F20210114022819.png","template":"获得###次点赞","variable":"138","url":null},{"icon":"https:\u002F\u002Fimg-home.csdnimg.cn\u002Fimages\u002F20210114022831.png","template":"内容获得###次评论","variable":"32","url":null},{"icon":"https:\u002F\u002Fimg-home.csdnimg.cn\u002Fimages\u002F20210114022828.png","template":"获得###次收藏","variable":"441","url":null}],"rankList":[]},"medalModule":[{"name":"勤写标兵Lv1","medalId":313,"description":"授予每个自然周发布1篇到3篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。","imageUrl":"https:\u002F\u002Fcsdnimg.cn\u002Fmedal\u002Fqixiebiaobing1@240.png","sourceUrl":"https:\u002F\u002Feditor.csdn.net\u002Fmd\u002F","whetherHave":true}],"interestModule":[{"id":1,"name":"后端","select":true,"together":false,"tags":[{"id":24,"name":"MySQL","select":true,"together":false,"tags":null},{"id":23,"name":"Spring Boot","select":true,"together":false,"tags":null},{"id":16,"name":"Java","select":true,"together":false,"tags":null},{"id":17,"name":"C\u002FC++","select":true,"together":false,"tags":null},{"id":25,"name":"Spring","select":true,"together":false,"tags":null},{"id":26,"name":"Redis","select":true,"together":false,"tags":null},{"id":29,"name":"Linux","select":true,"together":false,"tags":null}]}],"columnModule":[{"id":10833947,"app_id":1561979372,"username":"qiana_","alias":"","title":"问题解决","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918135101160.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":1,"sort":0,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":1}","created_at":"2021-02-25T21:14:37+08:00","updated_at":"2021-02-25T21:19:37+08:00","edit_title":"问题解决","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_10833947.html"},{"id":10113594,"app_id":1561979372,"username":"qiana_","alias":"","title":"log","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140129601.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":1,"sort":0,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":1}","created_at":"2020-06-17T16:53:26+08:00","updated_at":"2020-06-17T16:57:00+08:00","edit_title":"log","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_10113594.html"},{"id":6641344,"app_id":1561979372,"username":"qiana_","alias":"","title":"编程题","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140129601.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":4,"sort":6641344,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":4}","created_at":"2019-08-26T04:19:54+08:00","updated_at":"2019-11-22T09:29:45+08:00","edit_title":"编程题","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_6641344.html"},{"id":6645815,"app_id":1561979372,"username":"qiana_","alias":"","title":"知识点","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140129601.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":10,"sort":6645815,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":10}","created_at":"2019-08-26T04:19:54+08:00","updated_at":"2019-11-22T09:32:06+08:00","edit_title":"知识点","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_6645815.html"},{"id":6818824,"app_id":1561979372,"username":"qiana_","alias":"","title":"Linux","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140129601.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":16,"sort":6818824,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":16}","created_at":"2019-08-26T04:19:56+08:00","updated_at":"2019-11-22T11:29:40+08:00","edit_title":"Linux","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_6818824.html"},{"id":6990424,"app_id":1561979372,"username":"qiana_","alias":"","title":"c++","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140158853.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":24,"sort":6990424,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":24,\"32\":1}","created_at":"2019-08-26T04:19:58+08:00","updated_at":"2020-01-14T21:41:31+08:00","edit_title":"c++","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_6990424.html"},{"id":7296458,"app_id":1561979372,"username":"qiana_","alias":"","title":"排序","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140158853.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":6,"sort":7296458,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":6}","created_at":"2019-08-26T04:20:02+08:00","updated_at":"2019-11-22T15:33:42+08:00","edit_title":"排序","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_7296458.html"},{"id":7427001,"app_id":1561979372,"username":"qiana_","alias":"","title":"面试题","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140158853.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":18,"sort":7427001,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":18}","created_at":"2019-08-26T04:20:03+08:00","updated_at":"2019-11-22T16:31:08+08:00","edit_title":"面试题","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_7427001.html"},{"id":7506406,"app_id":1561979372,"username":"qiana_","alias":"","title":"网络","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140129601.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":1,"sort":7506406,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":1}","created_at":"2019-08-26T04:20:04+08:00","updated_at":"2019-11-22T17:09:56+08:00","edit_title":"网络","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_7506406.html"},{"id":7533766,"app_id":1561979372,"username":"qiana_","alias":"","title":"数据结构","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190927151101105.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":1,"sort":7533766,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":1}","created_at":"2019-08-26T04:20:05+08:00","updated_at":"2019-11-22T17:27:45+08:00","edit_title":"数据结构","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_7533766.html"},{"id":7569473,"app_id":1561979372,"username":"qiana_","alias":"","title":"MySQL","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140012416.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":4,"sort":7569473,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":4}","created_at":"2019-08-26T04:20:06+08:00","updated_at":"2019-11-22T17:45:56+08:00","edit_title":"MySQL","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_7569473.html"},{"id":7782201,"app_id":1561979372,"username":"qiana_","alias":"","title":"leetcode","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190927151026427.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":16,"sort":7782201,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":16}","created_at":"2019-08-26T04:20:08+08:00","updated_at":"2019-11-22T19:45:11+08:00","edit_title":"leetcode","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_7782201.html"},{"id":7885291,"app_id":1561979372,"username":"qiana_","alias":"","title":"软件测试","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190927151053287.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":3,"sort":7885291,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":3}","created_at":"2019-08-26T04:20:10+08:00","updated_at":"2019-11-22T20:44:10+08:00","edit_title":"软件测试","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_7885291.html"},{"id":7919827,"app_id":1561979372,"username":"qiana_","alias":"","title":"C++11","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140037908.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":2,"sort":7919827,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":2}","created_at":"2019-08-26T04:20:11+08:00","updated_at":"2019-11-22T21:03:08+08:00","edit_title":"C++11","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_7919827.html"},{"id":8030695,"app_id":1561979372,"username":"qiana_","alias":"","title":"操作系统","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190927151117521.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":1,"sort":8030695,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":1}","created_at":"2019-08-26T04:20:11+08:00","updated_at":"2019-11-22T22:06:07+08:00","edit_title":"操作系统","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_8030695.html"},{"id":8428639,"app_id":1561979372,"username":"qiana_","alias":"","title":"git","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140129601.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":1,"sort":8428639,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":1}","created_at":"2019-08-26T04:20:18+08:00","updated_at":"2019-11-23T01:59:06+08:00","edit_title":"git","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_8428639.html"},{"id":8523367,"app_id":1561979372,"username":"qiana_","alias":"","title":"Java","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190927151026427.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":2,"sort":8523367,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":2}","created_at":"2019-08-26T04:20:19+08:00","updated_at":"2021-01-19T20:55:18+08:00","edit_title":"Java","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_8523367.html"},{"id":8872735,"app_id":1561979372,"username":"qiana_","alias":"","title":"spring","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190927151043371.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":2,"sort":8872735,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":2}","created_at":"2019-08-26T04:20:24+08:00","updated_at":"2021-03-12T17:01:04+08:00","edit_title":"spring","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_8872735.html"},{"id":8987896,"app_id":1561979372,"username":"qiana_","alias":"","title":"ASP.NET","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F2019092715111047.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":1,"sort":8987896,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"0\":1}","created_at":"2019-08-26T04:20:25+08:00","updated_at":"2019-11-23T07:19:32+08:00","edit_title":"ASP.NET","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_8987896.html"},{"id":9175619,"app_id":1561979372,"username":"qiana_","alias":"","title":"环境配置","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140129601.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":4,"sort":9175619,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":4}","created_at":"2019-08-26T04:20:28+08:00","updated_at":"2020-07-02T18:42:55+08:00","edit_title":"环境配置","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_9175619.html"},{"id":9186806,"app_id":1561979372,"username":"qiana_","alias":"","title":"工具常见问题","desc":"","img_url":"https:\u002F\u002Fimg-blog.csdnimg.cn\u002F20190918140145169.png?x-oss-process=image\u002Fresize,m_fixed,h_64,w_64","channel_id":0,"sum":1,"sort":9186806,"is_show":1,"status":1,"is_free":0,"is_delete":2,"status_count":"{\"1\":1}","created_at":"2019-08-26T04:20:28+08:00","updated_at":"2019-11-23T09:07:47+08:00","edit_title":"工具常见问题","second":false,"url":"https:\u002F\u002Fblog.csdn.net\u002Fqiana_\u002Fcategory_9186806.html"}],"customModule":null,"latelyList":[{"type":"blog","formatTime":"2 月前","title":"一个接口有多个实现类时，@Resource注入失败问题","description":"问题描述接口：ExecuteServicepublic interface ExecuteService {    void doExecute(Context context);    void suspendTest(String taskId);}实现类1：UIExecuteServiceImpl@Servicepublic class UIExecuteServiceImpl implements ExecuteService {    @Resource    publ","hasOriginal":true,"diggCount":0,"commentCount":1,"postTime":1615470252000,"createTime":1615468212000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F114680199","articleType":1,"viewCount":80,"rtype":"article"},{"type":"blog","formatTime":"3 月前","title":"vscode的vim插件不能使用ctrl-c问题","description":"vscode更新后，发现和vim的使用一样了，应该是自动安装了vim插件，按i之后才可以使用。输入时发现，ctrl+c,ctrl+v使用不了了，以下是解决发方法：（1）方法一：卸载vim插件（2）方法二：打开File-&gt;Preferences-&gt;settings，搜索ctrl，找到Vim:Use Ctrl Keys，去掉前面的勾。但是这种方式将vim的ctrl功能都禁掉了。（3）方法三：搜索vim.handleKeys，打开settings.json文件.","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1614258876000,"createTime":1614258170000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F114106477","articleType":1,"viewCount":82,"rtype":"article"},{"type":"blog","formatTime":"10 月前","title":"win下配置jdk环境变量","description":"1. 配置JAVA_HOME：D:\\Program Files\\Java\\jdk1.8.0_1912. 配置CLASSPATH：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar3. 配置Path：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin注意：在Windows7中可以这样配置，在win10中这么配置可能会出现（'javac' 不是内部或外部命令，也不是可运行的程序 或批处理文件）这样的错误。解决：这么写，不用","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1593685714000,"createTime":1593685714000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F107090624","articleType":1,"viewCount":51,"rtype":"article"},{"type":"blog","formatTime":"10 月前","title":"SwitchyOmega安装时的“.crx程序包无效”问题","description":"1.什么是SwitchyOmega？SwitchyOmega是一款Chrome上的代理扩展程序，可用于翻墙。2.如何安装：https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F1070902463.在chrome:\u002F\u002Fextensions\u002F，打开开发者模式，将SwitchyOmega_Chromium.crx拖入其中，会出现“.crx程序包无效”。解决方法：（1）进入文件夹，修改扩展名为.zip或.rar（2）...","hasOriginal":true,"diggCount":2,"commentCount":0,"postTime":1593685546000,"createTime":1593685546000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F107090564","articleType":1,"viewCount":1501,"rtype":"article"},{"type":"blog","formatTime":"10 月前","title":"SwitchyOmega的安装与配置","description":"1.什么是SwitchyOmega？SwitchyOmega是一款Chrome上的代理扩展程序，可用于翻墙。2.如何下载：（1）谷歌应用商店下载：下载就需要翻墙╮(╯▽╰)╭（2）git下载地址：https:\u002F\u002Fgithub.com\u002FFelisCatus\u002FSwitchyOmega\u002Freleases下载.crx结尾的扩展程序3.安装与配置（1）安装：在地址栏输入chrome:\u002F\u002Fextensions 回车直接把下载好的 .crx 压缩包拖放到扩展程序管理（...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1593685312000,"createTime":1593685312000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F107090246","articleType":1,"viewCount":3375,"rtype":"article"},{"type":"blog","formatTime":"10 月前","title":"本地debug时出现:log4j:WARN No appenders could be found for logger","description":"将代码发布到远程服务器时，可以正常运行，本地debug时，在main函数中写了一段测试代码，debug时出现：log4j:WARN No appenders could be found for logger (org.apache.hadoop.metrics2.li)解决方法：将下面方法插入到入口点Main方法处，是一个快速的系统配置。作用是与log4j.properties快速关联起来，自动快速地使用缺省Log4j环境。BasicConfigurator.configure(); \u002F\u002F自.","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1592384025000,"createTime":1592384025000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F106812886","articleType":1,"viewCount":96,"rtype":"article"},{"type":"blog","formatTime":"1 年前","title":"如何使用idea远程debug","description":"当需要调试远程服务器上的代码时，就需要进行远程debug。java远程调试功能可导致远程执行任意命令，默认情况下在生产禁止使用。如有需要在生产环境使用，则必须监听在127.0.0.1，避免被远程调用。（1）开启远程调试参数：    修改远程服务器的tomcat配置文件startenv.sh，添加如下内容：export JAVA_OPTS=\"-Xdebug -Xrunjdwp:...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1583333093000,"createTime":1583333093000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F104664675","articleType":1,"viewCount":191,"rtype":"article"},{"type":"blog","formatTime":"2 年前","title":"解决idea项目中Error:java: 无效的标记: -version","description":"IDEA中提示：Warning:java: 源值1.5已过时, 将在未来所有发行版中删除https:\u002F\u002Fblog.csdn.net\u002Fstripeybaby\u002Farticle\u002Fdetails\u002F80010734解决idea项目中Error:java: 无效的标记: -version问题https:\u002F\u002Fwww.cnblogs.com\u002Flovezzb\u002Fp\u002F10072854.html...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1564649675000,"createTime":1564649675000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F98076233","articleType":1,"viewCount":1318,"rtype":"article"},{"type":"blog","formatTime":"2 年前","title":"IntelliJ IDEA配置","description":"使用IntelliJ IDEA配置JDK：https:\u002F\u002Fwww.cnblogs.com\u002FKnowledge-has-no-limit\u002Fp\u002F7234360.html使用IntelliJ IDEA创建Maven项目：https:\u002F\u002Fwww.cnblogs.com\u002FKnowledge-has-no-limit\u002Fp\u002F7235026.html使用IntelliJ IDEA配置Tomcat：...","hasOriginal":false,"diggCount":0,"commentCount":0,"postTime":1564389355000,"createTime":1564389355000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F97651388","articleType":2,"viewCount":65,"rtype":"article"},{"type":"blog","formatTime":"2 年前","title":"使用ASP.NET向MySQL数据库插入中文时乱码问题","description":"问题描述：使用ASP.NET写了一个问卷调查系统，使用注册，创建问卷等向数据库插入中文字符时，mysql数据库中乱码了。但是从数据库从读取的中文字符可以正常的显示。在数据库中是可以正常的插入中文字符。------------------------------------------------------------------------------------------------...","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1559029989000,"createTime":1559029989000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F90640265","articleType":1,"viewCount":1016,"rtype":"article"},{"type":"blog","formatTime":"2 年前","title":"MySQL数据库插入中文失败问题","description":"问题描述：创建数据库test字符集为utf8，表user字符集为utf8。插入中文字符时出现如下错误：ERROR 1366 (HY000): Incorrect string value: '\\xCE\\xE2\\xD9\\xBB' for column 'user_name' at row 1解决方法：方法一： 在mysql命令行下执行：SET NAMES GBK；（设置客户端字...","hasOriginal":true,"diggCount":3,"commentCount":0,"postTime":1559027839000,"createTime":1559027839000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F90639347","articleType":1,"viewCount":2800,"rtype":"article"},{"type":"blog","formatTime":"2 年前","title":"数据库中关于字符集的操作","description":"一、查看字符集1.查看MySQL数据库的字符集和校验规则(1) show variables like 'character%';(2) show variables like 'collation%'; (3) status;mysql&gt; show variables like 'character%';+--------------------------+----...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1558541858000,"createTime":1558541858000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F90454643","articleType":1,"viewCount":262,"rtype":"article"},{"type":"blog","formatTime":"2 年前","title":"SpringMVC各层之间的区别及联系","description":"项目分层实体层：bean、pojo、model等命名方式用途：和数据库的实体保持一致，还可以存放由数据库实体类而衍生的类，比如数据库实体类User中有一个字段experience，它的类型是Experience类，则Experience类也可存放于model文件夹中。数据传输层：dto层用途：用来进行数据的传输，是面向界面UI来进行设计的，是根据UI的需求来进行定义的。如果实...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1555588365000,"createTime":1555588365000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F89386069","articleType":1,"viewCount":2559,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"IntelliJ idea的常用快捷键","description":"IntelliJ新建一个类的快捷键是什么？选中文件夹，alt + insert如何快速打开一个类，比如，HashMap.java？ctrl + n，输入类名双击shift，输入类名如何进入到方法的定义处？鼠标放在类名处，按ctrl ，类名会变成超链接，点击即可如何回到进入该方法的上一处？ctrl+alt+ 左（Home）回到上一处ctrl+alt+ 右（End）...","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1544515123000,"createTime":1544515123000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F84956394","articleType":1,"viewCount":160,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"ubuntu下如何上传代码到码云","description":"下面的指令都在命令行执行。一：安装与配置第一步：在ubuntu下安装git。以下实例在ubuntu下进行。确认你的系统是否安装了git，通过git指令进行查看。如果没有安装，就使用命令sudo apt-get install git来进行安装。Centos下git的安装和ubuntu不太一样，使用yum进行安装。 第二步：安装完成后进行git的配置。git config ...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1543076870000,"createTime":1543076870000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F84451356","articleType":1,"viewCount":2035,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"死锁及其必要条件","description":"1.简介在计算机系统中会出现很多一次只能由一个进程使用的资源，比如打印机，磁带机等，在多道程序设计中，若干进程要共享这类的资源，而且一个进程所需要的不止一个，这样，就会出现若干个进程竞争优先有限资源，由于推进顺序不当，就会曹成无限期的循环等待的局面，这种状态就是死锁。2.什么是死锁？所谓死锁，是指多个进程在运行过程中因竞争资源而需要循环等待对方释放资源的一种僵局。互相等待对方释放资源，...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1536482127000,"createTime":1536482127000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F82556330","articleType":1,"viewCount":294,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"linux下的ctrl+z, ctrl+c, ctrl+d, ctrl+h的区别","description":"在Linux下当我运行一个http服务器的时候，按下ctrl+z，发现进程退出了，再次运行的时候，发现端口被占用，于是就用kill -9 杀死这个进程或者在进程运行的时候按下ctrl+c退出进程。使用ctrl+c退出进程，就是真的退出了。那ctrl+z和ctrl+c都是中断命令，那它们有什么区别？Ctrl+z :当按下ctrl+z时，系统会发送SIGTSTP（20号信号）给前台进程组中的所...","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1535631700000,"createTime":1535631700000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F82227045","articleType":1,"viewCount":1382,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"顺时针打印矩阵","description":"题目描述：对于一个矩阵，请设计一个算法从左上角(mat[0][0])开始，顺时针打印矩阵元素。给定int矩阵mat,以及它的维数nxm，请返回一个数组，数组中的元素为矩阵元素的顺时针输出。测试样例：[[1,2],[3,4]],2,2返回：[1,2,4,3]题目解析：将问题分解为一下几个步骤：1）从左到右打印矩阵2）从上到下打印矩阵3）从右到左打印矩阵...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1535443781000,"createTime":1535443781000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F82149581","articleType":1,"viewCount":103,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"静态数据成员和静态成员函数","description":"转载自：https:\u002F\u002Fblog.csdn.net\u002Fcomputer_liuyun\u002Farticle\u002Fdetails\u002F29235111c++中的static静态数据成员和静态成员函数应该是让大家比较头疼的东西，好像也是找工作公司面试中常常问到的东西。我自己也深有体会，在学习c++的过程中，总感觉static很烦人，但是又是一个必须懂的东西，所以今天就对静态数据成员和静态成员函数坐下小结哈！一...","hasOriginal":false,"diggCount":97,"commentCount":14,"postTime":1535282315000,"createTime":1535282315000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F82083313","articleType":2,"viewCount":21070,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"理解POD数据类型","description":"1.什么是POD？POD全称Plain Old Data。字面意思，普通的，旧的数据类型。通俗的讲，一个类或结构体通过二进制拷贝后还能保持其数据不变，那么它就是一个POD类型。2.C++11中的定义在维基百科中有：C ++中的普通旧数据结构是一个聚合类，它只包含PDS作为成员，没有用户定义的析构函数，没有用户定义的复制赋值运算符，也没有指向成员类型的非静态成员。被动数据结构（PDS...","hasOriginal":true,"diggCount":2,"commentCount":0,"postTime":1535269853000,"createTime":1535269853000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F82078183","articleType":1,"viewCount":1357,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"数据库和表的基本操作","description":"1.什么是数据库：高效的存储和处理数据的介质（介质有：磁盘和内存）文件保存数据的缺点：文件的安全性问题\t文件不利于查询和对数据的管理\t文件不利于存放海量数据\t文件在程序中控制不方便2.连接数据库：在Linux下要使用mysql数据库，首先要开启mysqld服务（mysqld服务是数据库的服务器端）：[root@localhost http]$ service mysq...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1535028122000,"createTime":1535028122000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81982574","articleType":1,"viewCount":159,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"测试用例的基本介绍","description":"1.什么是测试用例？测试用列（Test Case）是为了实施测试二向被测试的系统提供的一组集合，这组集合包含：测试环境、操作步骤、测试数据、预期结果等要素。2.测试用例的要素测试用例的标题、测试思路、预设条件、步骤、预期输出一个好的测试用例是一个不熟悉业务的人也能依据用例来很快的进行测试。评价测试用例的标准：用例表达清楚，无二义性用例可操作性强永猎的输入与输出明确...","hasOriginal":true,"diggCount":5,"commentCount":5,"postTime":1535008622000,"createTime":1535008622000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81951392","articleType":1,"viewCount":7811,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"TCP连接建立与释放（三次握手、四次挥手）","description":"TCP协议的工作原理：TCP连接建立、报文传输、TCP连接释放。1.TCP连接建立：三次握手（1）最初客户端TCP进程是处于“CLOSE”（关闭）状态。当客户端准备发起一次TCP连接，进入“SYN-SEND”（准备发送）状态时，它会向处于“LISTEN”（收听）状态的服务器端TCP进程发送第一个控制位SYN=1的“连接建立请求报文”。“连接建立请求报文”是不携带任何数据字段的，但是...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534925446000,"createTime":1534925446000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81939921","articleType":1,"viewCount":713,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"XXXX is not in the sudoers file. This incident will be reported解决方法","description":"XXXX is not in the sudoers file.  This incident will be reported解决方法假设你用的是Red Hat系列（包括Fedora和CentOS）的Linux系统。当你执行sudo命令时可能会提示“某某用户 is not in the sudoers file.  This incident will be reported.”解决方法:...","hasOriginal":false,"diggCount":0,"commentCount":0,"postTime":1534682397000,"createTime":1534682397000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81841513","articleType":2,"viewCount":756,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"解决类似 \u002Fusr\u002Flib64\u002Flibstdc++.so.6: version `GLIBCXX_3.4.21' not found 的问题","description":"源码编译升级安装了gcc后，编译程序或运行其它程序时，有时会出现类似\u002Fusr\u002Flib64\u002Flibstdc++.so.6: version `GLIBCXX_3.4.21' not found的问题。这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库导致的，将gcc最新版本的动态库替换系统中老版本的动态库即可解决。 1. 问题原因分析为了安装最新版本的Node.js（最新版本...","hasOriginal":false,"diggCount":0,"commentCount":0,"postTime":1534667443000,"createTime":1534667443000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81839006","articleType":2,"viewCount":579,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"Centos6.5 安装boost库","description":"要使用boost中的有些内容，在网上找了一下，有些安装很复杂。最终找到了一个很简单的安装boost的方法。环境：Centos6.5   gcc 4.8.2  g++ 4.8.2yum install boostyum install boost-develyum install boost-doc测试一下：代码来自：https:\u002F\u002Fblog.csdn.net\u002Fqiuyouj...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534587955000,"createTime":1534587955000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81811465","articleType":1,"viewCount":1037,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode: construct-binary-tree-from-inorder-and-postorder-traversal  使用中序和后序遍历重建二叉树","description":"题目描述：Given inorder and postorder traversal of a tree, construct the binary tree.Note:You may assume that duplicates do not exist in the tree.题目解析： \u002F\u002F题目：construct-binary-tree-from-inorder-a...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534560116000,"createTime":1534560116000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81805733","articleType":1,"viewCount":138,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode : same-tree：判断是不是相同的树","description":"题目描述：Given two binary trees, write a function to check if they are equal or not.Two binary trees are considered equal if they are structurally identical and the nodes have the same value.题目解析：...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534555640000,"createTime":1534555640000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81805516","articleType":1,"viewCount":127,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode: binary-tree-postorder-traversal:后序遍历二叉树","description":"题目描述：Given a binary tree, return the postorder traversal of its nodes' values.For example:Given binary tree{1,#,2,3},   1    \\     2    \u002F   3return[3,2,1].Note: Recursive solution is tr...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534507803000,"createTime":1534507803000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81782729","articleType":1,"viewCount":113,"rtype":"article"},{"type":"download","formatTime":"3 年前","title":"二分法解非线性方程","description":"二分法解非线性方程，输入区间，可以误差限，可以求得非线性方程的根","fileType":"cpp","createTime":1534496553000,"url":"https:\u002F\u002Fdownload.csdn.net\u002Fdownload\u002Fqiana_\u002F10611042","rtype":"file"},{"type":"download","formatTime":"3 年前","title":"软件测试面试突击","description":"该书讲了软件测试的基础知识，黑盒测试，白盒测试，测试用例，系统测试，单元测试，测试工程师的面试题等内容。","fileType":"pdf","createTime":1534496056000,"url":"https:\u002F\u002Fdownload.csdn.net\u002Fdownload\u002Fqiana_\u002F10611018","rtype":"file"},{"type":"blog","formatTime":"3 年前","title":"atoi和itoa的模拟实现","description":"1.atoi函数：函数原型：int atoi (const char * str);该函数的功能是将字符串转化为整型。分以下几种情况：1）如果该字符串的最开始是 -，并且后面加的是数字，那么转化的整数是负整数。2）如果该字符串的最开始是+ 或者是数字，那么转化的是正整数。3）如果最开始是-\u002F+ 加其他字符，就是不合法的，直接返回0.4）考虑溢出，正溢出和负溢出。模...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534478033000,"createTime":1534478033000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81774444","articleType":1,"viewCount":142,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"C语言中的常见字符串操作函数","description":"以下函数的头文件位于#include&amp;lt;string.h&amp;gt;1.strcat函数：函数原型：char * strcat ( char * destination, const char * source );该函数是字符串拼接函数。将源字符串拼接至目标字符串的结尾处。要覆盖目标字符串中的'\\0'。source和destination的空间不能重叠，而且destination...","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1534391929000,"createTime":1534391929000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81737821","articleType":1,"viewCount":163,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"序列化二叉树","description":"题目描述：请实现两个函数，分别用来序列化和反序列化二叉树。题目解析：序列化：将一颗二叉树序列化，以前序遍历的顺序序列化，从根节点开始，将节点的值转换为字符，存入一个字符串中，每存一个值，再加上一个',' ，当遍历到空节点的时候，加上'#'。反序列化：将一个字符串还原为一个二叉树，将字符0-9转换为字符 （ch - '0'）。转换为整型后，创建一个节点其值为该整型。再递归的调用左子树...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534337509000,"createTime":1534337509000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81710657","articleType":1,"viewCount":77,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode:  binary-tree-preorder-traversal","description":"题目描述：Given a binary tree, return the preorder traversal of its nodes' values.For example:Given binary tree{1,#,2,3},   1    \\     2    \u002F   3 return[1,2,3].Note: Recursive solution i...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534336522000,"createTime":1534336522000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81710551","articleType":1,"viewCount":109,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"对称的二叉树","description":"题目描述：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。题目解析：思路：从根节点开始，判断它的左子树和右子树是否相等，它们的值是否相等。再递归的判断左子树的左子树和右子树的右子树是否相等，左子树的右子树和右子树的左子树是否相等。AC代码：\u002F*struct TreeNode {    int val;  ...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534300512000,"createTime":1534300512000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81699786","articleType":1,"viewCount":116,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"二叉搜索树的后序遍历序列","description":"题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。题目解析：对于后序遍历的序列来说，最后一个值应该是根节点。二叉搜索树的左子树都比根节点小，右子树都比根节点大。因此，对于后序序列，倒着往前找，比最后一个节点大的是二叉树的右子树的节点，比最后一个节点小的是二叉树的左子树的节点。如果在本该是右...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534212937000,"createTime":1534212937000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81661697","articleType":1,"viewCount":112,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"二叉树的下一个节点","description":"题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针next。题目解析：给定一棵二叉查找树，注意参数部分传的是这个节点，而不是二叉树的根节点。查找中序遍历的下一个节点，如果该结点是最大的，则返回 NULL。其他的情况有以下的图解：AC代码：\u002F*struct TreeLinkNode...","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1534176166000,"createTime":1534176166000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81639302","articleType":1,"viewCount":335,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"重建二叉树","description":"题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。题目解析：通过前序遍历的序列和中序遍历的序列，构建出二叉树，从前序遍历的特点可以看出，其序列的第一个节点是根节点，先是遍历完左子树，再进行遍历...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1534175744000,"createTime":1534175744000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81639227","articleType":1,"viewCount":142,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"链接属性","description":"C语言中的链接属性决定如何处理在不同文件中出现的标识符，标识符的作用域和它的链接属性有关。链接属性的分类：外部链接属性：全局标识符具有链接属性（全局变量）；使用关键字extern声明的变量或函数，可以在其它的源文件中使用；外部链接属性就意味着，一个标识符，不仅可以在当前的源文件中使用，还可以在程序的其他文件中使用。test.cint g_val = 10;  \u002F\u002F具有...","hasOriginal":true,"diggCount":0,"commentCount":1,"postTime":1534132070000,"createTime":1534132070000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81624686","articleType":1,"viewCount":946,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"二叉树的深度","description":"题目描述：输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。题目解析：采用递归遍历：1）如只有1个节点，深度就为12）当前结点的深度就是它的左子树和右子树中深度大的一个再加1.\u002F*struct TreeNode {\tint val;\tstruct TreeNode *left;\tstru...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533955575000,"createTime":1533955575000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81584012","articleType":1,"viewCount":103,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"二叉树的镜像","description":"题目描述：操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树     \t    8    \t   \u002F  \\    \t  6   10    \t \u002F \\  \u002F \\    \t5  7 9 11    \t镜像二叉树    \t    8    \t   \u002F  \\    \t  10   6    \t \u002F \\  \u002F \\    \t11 9 7  ...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533951753000,"createTime":1533951753000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81583294","articleType":1,"viewCount":388,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"STL之Stringstream字符串流使用总结","description":"转载自：https:\u002F\u002Fblog.csdn.net\u002Ffanyun_01\u002Farticle\u002Fdetails\u002F66967710如果你已习惯了&amp;lt;stdio.h&amp;gt;风格的转换，也许你首先会问：为什么要花额外的精力来学习基于&amp;lt;sstream&amp;gt;的类型 转换呢？也许对下面一个简单的例子的回顾能够说服你。假设你想用sprintf()函数将一个变量从int类型转换到字符串类型。为了正确地完成...","hasOriginal":false,"diggCount":0,"commentCount":0,"postTime":1533911199000,"createTime":1533911199000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81570697","articleType":2,"viewCount":109,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"把二叉树打印成多行","description":"题目描述：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。题目解析：采用层序遍历的思想。将节点push进队列中，当队列不为空时，增加两个变量，一个用来计数，一个用来获取当前队列中的节点个数。当计数小于总数时，说明这些节点在一层中，将这些节点push_back进vector1中。再遍历当前结点的左子树和右子树，将vector1 push_back 进vector2中。队列...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533804475000,"createTime":1533804475000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81539619","articleType":1,"viewCount":149,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"C++11新特性1","description":"C++11中增加了一些新的特性，需要在vs2011（或Linux g++4.8，编译时需要加-std=c++11）之后的版本中才可进行语法解析。1、nullptr常量nullptr的出现是为了替换NULL，nullptr是一种特殊类型的字面值，可以被转换成任意的其他类型的指针。传统的C++，NULL和0的意义是一样的。有些编译器会将NULL定义为((void*)0)，有的编译器会将NU...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533733938000,"createTime":1533733938000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81513143","articleType":1,"viewCount":81,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode: remove-nth-node-from-end-of-list：删除倒数第n个节点","description":"题目描述：Given a linked list, remove the n th node from the end of list and return its head.For example,   Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.   After removing the second nod...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533655286000,"createTime":1533655286000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81490361","articleType":1,"viewCount":84,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode: rotate-list:旋转链表","description":"题目描述：Given a list, rotate the list to the right by k places, where k is non-negative.For example:Given1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULLand k =2,return4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL.题目解析：...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533648886000,"createTime":1533648886000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81488907","articleType":1,"viewCount":82,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode : add-two-numbers","description":"题目描述：You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533644762000,"createTime":1533644762000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81487772","articleType":1,"viewCount":59,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"用两个栈实现队列","description":"用两个栈实现队列：栈 是先进的后出来，队列是先进的先出来。入队列：直接push进stack1出队列：如果两个队列都为空就直接返回。如果stack2为空，就将stack1中的元素push进Stack2中，再对Stack2进行pop，此时就相当于pop了队列（入栈的一个元素）。如果stack2不为空，就直接pop stack2中的元素。AC代码：class Solution{...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533643374000,"createTime":1533643374000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81487319","articleType":1,"viewCount":82,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"公交卡的测试用例","description":"下面以思维导图的方式写出公交卡的测试用例：(*^▽^*)","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1533639967000,"createTime":1533639967000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81486751","articleType":1,"viewCount":1069,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"LeetCode：reorder-list：重排链表","description":"题目描述：Given a singly linked list L: L 0→L 1→…→L n-1→L n,reorder it to: L 0→L n →L 1→L n-1→L 2→L n-2→…You must do this in-place without altering the nodes' values.For example,Given{1,2,3,4}, reo...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533523947000,"createTime":1533523947000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81450177","articleType":1,"viewCount":121,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"LeetCode：partition-list:对链表进行分区","description":"题目描述：Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in ea...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533522899000,"createTime":1533522899000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81450073","articleType":1,"viewCount":113,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode: convert-sorted-list-to-binary-search-tree：将排序的链表转换成二叉搜索树","description":"题目描述：Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.题目解析：通过快慢指针找到链表的中点，作为二叉搜素树的根节点。以中点为界，将链表分为两部分，不包含中点，分别对两部分链表递归调用原函数，最后连上根节点的左右子树...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533522628000,"createTime":1533522628000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81449793","articleType":1,"viewCount":69,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"LeetCode：sort list","description":"题目描述：Sort a linked list in O(n log n) time using constant space complexity.题目解析：使用O(nlogn)的算法排序数组。O(nlogn)的排序算法有快速排序，归并排序，堆排序。这里使用归并排序。归并排序的一般步骤为：（1）将待排序链表，取中点，一分为二；（2）递归地对左半部分进行归并排序；（3）...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533486076000,"createTime":1533486076000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81437536","articleType":1,"viewCount":44,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"二叉搜索树与双向链表","description":"题目描述：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。题目解析：二叉搜索树使用中序遍历就是有序的，将二叉树转换成双向链表，就是要改变指针的指向。比如，作左子树的right = 根，根的left = 左子树，根的right = 右子树 ，右子树的left = 根。AC代码：\u002F*struct TreeN...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533194165000,"createTime":1533194165000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81356119","articleType":1,"viewCount":46,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"求两个链表的第一个公共结点","description":"题目描述：输入两个链表，找出它们的第一个公共结点。题目分析：两个链表要有公共结点，就必须要有公共的尾部，从最后一个节点开始，最后一个不相等的节点就是第一个公共的节点。方法一：使用栈来实现：将两个链表分别push进两个栈中，然后不断的pop，用一个FirCom来记录相等的节点，pop一个值，就更新一下FirCom，最后一次记录的FirCom值就是第一个公共的节点。AC代码：...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533181218000,"createTime":1533181218000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81355557","articleType":1,"viewCount":59,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"复杂链表的复制","description":"题目描述：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）题目解析：复杂链表有一个next指针，指向下一个节点，一个random指针，可以指向任意的节点。复杂链表的复制分为三步：1.复制原链表，在原链表的每个节点后...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533116384000,"createTime":1533116384000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81333978","articleType":1,"viewCount":54,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"LeetCode：triangle","description":"题目描述：Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.For example, given the following triangle[     [2],    [3,4],...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533111782000,"createTime":1533111782000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81332332","articleType":1,"viewCount":66,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"剑指offer：合并两个排序的链表","description":"解题思路：两个链表是排序好的，比较两个链表的头结点的值，小的那个结点做新链表的头结点。依次比较各个节点的值，有序的链入到新链表中。其中一个链表已经比较完了，将另一个链表剩下的结点都链入到新链表中。在线AC：\u002F*struct ListNode {\tint val;\tstruct ListNode *next;\tListNode(int x) :\t\t\tval(x), next(NU...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1533109990000,"createTime":1533109990000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81332008","articleType":1,"viewCount":52,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"智能指针","description":"本文主要讨论C++标准库中的auto_ptr，boost库中的scoped_ptr, shared_ptr, weak_ptr1.什么是RAII       RAII全称为Resourse Acquisition Is Initialization，意为资源分配即初始化，定义一个类来封装资源的分配和释放，在构造函数完成资源的分配和初始化，在析构函数完成自愿的清理，可以保证资源的正确初始化和...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1532955101000,"createTime":1532955101000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81281289","articleType":1,"viewCount":61,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"软件测试的基本介绍","description":"1.什么是软件测试？软件测试是为了验证软件功能是否满足用户的需求。它有两个方面的含义：一、找出软件存在的bug        二、证明软件不存在错误的过程，即验证软件是正确的。软件测试的定义随着发展而不断扩展，但是不可否认的是软件测试最基本的活动就是找bug。而不同的定义只是说明了测试的目的以及如何来衡量测试是否成功。2.软件测试的发展过程 软件调试：软件测试是伴随着软件的...","hasOriginal":true,"diggCount":1,"commentCount":1,"postTime":1532780515000,"createTime":1532780515000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81262668","articleType":1,"viewCount":1198,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"使用C语言判断一个机器是大端机还是小端机","description":"1.什么是大端，什么是小端？大端：数据的高位字节存放在低地址内，数据的低位字节存放在高地址内。小端：数据的高位字节存放在高地址内，数据的低位字节存放在低地址内。一个整型是4个字节，如：0x1a2b3c4d。电脑读取内存数据时，是从低位地址到高位地址进行读取（从左到右）。在小端机器中从低地址到高地址的存放方式为：0x4d,0x3c,0x2b,0x1a；(低地址存低位)在大端机器中...","hasOriginal":true,"diggCount":5,"commentCount":3,"postTime":1532685451000,"createTime":1532685451000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81239869","articleType":1,"viewCount":4339,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode: sort-colors  颜色排序","description":"题目描述：Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1531816384000,"createTime":1531816384000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81083449","articleType":1,"viewCount":130,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode : marge-intervals:合并区间","description":"题目描述：Given a collection of intervals, merge all overlapping intervals.   For example, Given[1,3],[2,6],[8,10],[15,18],  return[1,6],[8,10],[15,18].解题思路：    题目的意思是：一个vector中存着Interval对象，Interval是一个结构体，...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1531583445000,"createTime":1531583445000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F81048708","articleType":1,"viewCount":91,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"leetcode:  restore-ip-address(恢复ip地址)","description":"题目描述：Given a string containing only digits, restore it by returning all possible valid IP address combinations.For example:Given &quot;25525511135&quot;,return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does ...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1531213061000,"createTime":1531213061000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80980456","articleType":1,"viewCount":352,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"Leetcode:  search-for-a-range","description":"题目描述：Given a sorted array of integers, find the starting and ending  position of a given target value.   Your algorithm's runtime complexity must be in the order of  O(log n).   If the target is not f...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1530846632000,"createTime":1530846632000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80937904","articleType":1,"viewCount":104,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"Leetcode: search-insert-position","description":"题目描述：Given a sorted array and a target value, return the index if the  target is found. If not, return the index where it would be if it were  inserted in order.   You may assume no duplicates in the ...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1530845714000,"createTime":1530845714000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80937476","articleType":1,"viewCount":149,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"连续子数组的最大和","description":"题目描述：输入一个整型数组，数组理由整数也有负数。数组中有一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。输入：3 -1 1 2  （3为输入的个数，后面3个位数组中的元素{-1,1,2}）输出：3   （1+2=3）输入：8 1 -2 3 10 -4  7 2 -5    （数组为{1,-2,3,10,-4,7,2,-5}）输出：18   （3,10，-4...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1527868736000,"createTime":1527868736000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80544042","articleType":1,"viewCount":104,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"面试题：二维数组中的查找","description":"题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。例如在如下的数组中查找数字7的过程如下：数组： 1    2     8      9           2    4     9     12           4    7    10    13          ...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1527589701000,"createTime":1527589701000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80499398","articleType":1,"viewCount":135,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"数组中出现次数超过一半的数字","description":"题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}，由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2.这道题出自《剑指offer》中的面试题。一种简单的算法是，先对数组进行排序，排序之后位于数组中间的数字就一定是出现次数超过数组长度一半的数字。排序算法的时间复杂度为O(nlogn)。下面是两个O(N)...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1527504680000,"createTime":1527504680000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80467863","articleType":1,"viewCount":113,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"Linux 信号signal","description":"1. 信号的基本概念    联系现实生活中的信号，我们可以理解为：Linux中的signal其实就是一种标志，操作系统知道这个标志代表着什么含义，以及知道遇见这个标志它应该采取怎样的动作。（如红灯信号，你知道红灯信号代表着不能通过马路，而你采取的动作就是等待）1.1 信号的分类：使用kill -l : 可以查看系统定义的信号列表。总共有62种信号。1-31号信号称为普通信号，34-64号信号称为实...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1527087134000,"createTime":1527087134000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80367272","articleType":1,"viewCount":81,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"进程间通信---信号量","description":"信号量的有关概念：信号量：主要用于同步与互斥。为了防止出现因多个进程访问临界资源而引发的一系列问题，信号量可以提供这样一种访问机制，在任一时刻只能有一个执行线程访问代码的临界区域，也就是说信号量是用来协调进程对临界资源的访问。信号量的操作：信号量是一种特殊的变量，对信号量的访问必须是原子操作，信号量的操作只有两种：P操作（-1，申请资源）和V操作（+1，释放资源）。最简单的信号量只有两种取值0和1...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1525920560000,"createTime":1525920560000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80196557","articleType":1,"viewCount":104,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"jsoncpp的安装与配置","description":"网上有和很多的文章介绍jsoncpp的安装，本人走了不少歧路，在此分享一下自己的安装步骤。安装jsoncpp前必须安装scons。1.scons下载地址：http:\u002F\u002Fsourceforge.net\u002Fprojects\u002Fscons\u002Ffiles\u002Fscons\u002F2.1.0\u002Fscons-2.1.0.tar.gz\u002Fdownload2.jsoncpp下载地址：http:\u002F\u002Fsourceforge.net\u002Fpro...","hasOriginal":true,"diggCount":1,"commentCount":3,"postTime":1525699684000,"createTime":1525699684000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80231199","articleType":1,"viewCount":1391,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"进程间通信---共享内存（Shared Memory）","description":"共享内存的概念：共享内存是进程间通信（IPC）中最简单的方式之一，也是最快的IPC形式。共享内存允许两个或多个进程访问同一块内存。当一个进程改变了这块内存中的内容的时候，其他进程就可以察觉到这种更改。一旦这样的内存映射到共享它的进程的地址空间，这些进程间的数据传递将不再涉及到内核，即进程不再通过执行进入内核的系统调用来传递数据，而是这些进程通过共享内存来传递数据。共享内存的原理：共享内存就是有一块...","hasOriginal":true,"diggCount":4,"commentCount":0,"postTime":1525101692000,"createTime":1525101692000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F80150565","articleType":1,"viewCount":946,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"指针和引用","description":"1. 指针：指针是一个变量（对象），它的内容是一个地址，指向内存的一个存储单元。通过修饰符“*”来表示，解引用 *p 来表示指针p所指对象的值。指针在逻辑上是独立的，可以改变，比如指针变量的值和指针变量指向的内存的值都是可以改变。不同类型的指针可以指向特定类型的对象，即指针的类型要与所指向的对象的类型一致。可通过指针的指向来改变所指向的对象的值。const指针：常量指针const int *p;...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1524153677000,"createTime":1524153677000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79995676","articleType":1,"viewCount":68,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"进程间通信---管道和消息队列","description":"进程间通信的目的：数据传输：一个进程需要将它的数据发送给另一个进程资源共享：对个进程之间共享同样的资源通知事件：一个进程需要向另一个或一组进程发送消息，通知它们发生了什么事件进程控制：有些进程希望完全控制另一个进程的执行（如：Debug进程）进程间通信的发展：管道：System V进程间通信：POSIX进程间通信：进程间通信的分类：管道：我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”...","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1524151295000,"createTime":1524151295000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79778657","articleType":1,"viewCount":342,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"std::strcpy、strncpy、memset、memcpy用法","description":"转载自：https:\u002F\u002Fblog.csdn.net\u002Fjin13277480598\u002Farticle\u002Fdetails\u002F535422091. std::strcpy 功能：将一个字符串复制到另一个字符串（如果字符串重叠，该行为是未定义）； 定义于头文件 &amp;lt;cstring&amp;gt; char *strcpy( char *dest, const char *src );参数： dest    :指向复...","hasOriginal":false,"diggCount":0,"commentCount":0,"postTime":1523957848000,"createTime":1523957848000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79978075","articleType":2,"viewCount":169,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"memcpy和memmove","description":"memcpy功能：内存拷贝函数，从数据源拷贝num个字节的数据到目标数组函数原型：void * memcpy ( void * destination, const void * source, size_t num );函数参数：destination：指向目标数组的指针source：指向数据源的指针num：要拷贝的字节数使用方法：#include&amp;lt;stdio.h&amp;gt;#include...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1523956343000,"createTime":1523956343000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79951106","articleType":1,"viewCount":460,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"右值引用","description":"右值引用是C++11提出的新概念，通过这些操作，可以降低拷贝带来的消耗。左值和右值左值一般位于赋值号的左边，指的是一个对象本身，或者是一个持久的值，可以被多次引用和使用。例如赋值的返回值、下标操作、解引用以及前置递增等。左值必须在内存中有实体。右值是一个短暂的值，代表对象的值，一般不可以引用，只在当前的表达式中有效。比如一个表达式的求值结果、函数返回值以及一个字面值等。（不一定是赋值号右边的值）右...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1523892816000,"createTime":1523892816000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79908432","articleType":1,"viewCount":155,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"动态内存管理","description":"内存：      内存又叫内存储器，在冯诺依曼体系结构中，外设不能和CPU直接进行数据交流，外设可以和内存进行输入和输出，内存可以和CPU（运算器和控制器）进行数据交流。程序运行是要加载到内存中才能执行，变量需要申请内存才能被执行。申请了资源（内存）就要释放资源，不进行释放，CPU占有量会越来越大，其他进程就申请不到资源，就会造成内存泄露，对于普通的电脑来说，最终的结果就是关机，但对于大型服务器来...","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1523626977000,"createTime":1523626977000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79930799","articleType":1,"viewCount":258,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"linux（centos）下安装boost库及使用","description":"转载自：https:\u002F\u002Fblog.csdn.net\u002Ftimekeeperl\u002Farticle\u002Fdetails\u002F50622633一、安装       刚刚使用linux系统，对很多系统命令和操作方式还不是很熟悉。想装个boost库，在网上看了几篇教程根本没弄明白，终于，用三行命令解决了。      yum install boost      yum install boost-devel      ...","hasOriginal":false,"diggCount":1,"commentCount":1,"postTime":1523536466000,"createTime":1523536466000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79919686","articleType":2,"viewCount":13732,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"mysql报错Fatal error: Can't open and lock privilege tables: Table 'mysql.host' doesn't exist","description":"参考自：https:\u002F\u002Fblog.csdn.net\u002Findexman\u002Farticle\u002Fdetails\u002F16980433今天在启动mysql时，没有启动成功，查看日志报错如下:1、查看报错信息如下:[root@localhost local]# cd  \u002Fvar\u002Flog\u002Fmysqld.log | grep 'ERROR'[ERROR] Fatal error: Can't open and lock...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1523071415000,"createTime":1523071415000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79839901","articleType":1,"viewCount":3834,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"进程的有关概念","description":"什么是进程：进程是程序的一个执行实例，是系统进行资源分配和调度的一个基本单位。程序段、相关数据段和PCB三部分构成，又叫进程实体、进程映像。所谓创建进程，实质上是创建进程实体中的PCB，撤销进程，实质上是撤销进程的PCB。什么是PCB：为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须位置配置一个专门的数据结构，称为进程控制块（Process Control Block，PCB...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1522568399000,"createTime":1522568399000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79778483","articleType":1,"viewCount":170,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"C++之位图","description":"1.概念位图（bitset）是一种常用的数据结构，常用在给一个很大范围的数，判断其中的一个数是不是在其中。在索引、数据压缩方面有很大的应用。位图是用数组实现的，数组的每一个元素的每一个二进制位都表示一个数据，0表示该数据不存在，1表示该数据存在。2.C++库中bitset的使用3.bitset的简单实现当我们存放一个数据时的思路是：1）确定数据在哪个区间上，即_bitSet的第几个元素上，_bit...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1521821279000,"createTime":1521821279000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79672857","articleType":1,"viewCount":2018,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"特殊的数据类型：socklen_t、uint32_t、pthread_t","description":"在编程的时候，发现了一些不知道什么类型的数据类型，于是整理了一下。1.socklen_t是一种数据类型，它其实和int差不多，在32位机下，size_t和int的长度相同，都是32 bits,但在64位机下，size_t（32bits）和int（64 bits）的长度是不一样的,socket编程中的accept函数的第三个参数的长度必须和int的长度相同。于是便有了socklen_t类型。int...","hasOriginal":true,"diggCount":5,"commentCount":1,"postTime":1521387834000,"createTime":1521387834000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79552087","articleType":1,"viewCount":2991,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"编写代码，演示多个字符从两端移动，向中间汇聚。","description":"就是有两个字符串数组。代码实现：#include&amp;lt;Windows.h&amp;gt;int main(){\tchar arr1[] = &quot;###################&quot;;\tchar arr2[] = &quot;welcome to world!!!&quot;;\tint left = 0;\tint right = strlen(arr1)-1;\tprintf(&quot;%s\\n&quot;,arr1);\twh...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1520646809000,"createTime":1520646809000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79505245","articleType":1,"viewCount":100,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"逻辑题：确定5位运动员的比赛名次。","description":" 题目：5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果A选手说：B第一，我第三。B选手说：我第二，E第四。C选手说：我第一，D第二。D选手说：C最后，我第三。E选手说：我第四，A第一。比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。思路：A,B,C,D,E的比赛名次都有可能是第一名到第四名。所以用5个for循环，在for循环里，进行if条件判断，输出比赛名次。void Rank(...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1520646346000,"createTime":1520646346000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79505109","articleType":1,"viewCount":521,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"写一个函数返回参数二进制中1的个数","description":"问题：写一个函数返回参数二进制中1的个数。例如：10的二进制位为00000000 00000000 00000000 00001010 ，其中1的个数有2个。解法一：10的二进制：1010    5的二进制：0101      2的二进制：0010    1的二进制：0001     0的二进制：0000value\u002F2 相当于右移一位，当value==0时，跳出循环。当value%2 == 1时，...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1520303059000,"createTime":1520303059000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79454126","articleType":1,"viewCount":162,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"归并排序","description":"什么是归并排序？             归并排序采用了分治法（divide-and-conquer），将原问题分解为一些规模较小的相似子问题，然后递归解决这些子问题，最后合并其结果作为原问题的解。归并排序的算法通常用递归实现，将带排序的区间[a,b]二分，再二分，直至每个小区间只有一个元素，则每个小区间都是有序的，将小区间两两有序合并，直至成为一个区间，此时该区间是有序的。完成归并排序主要有两个...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1519463686000,"createTime":1519463686000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79363491","articleType":1,"viewCount":220,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"快速排序的非递归实现","description":"快速排序的非递归主要使用栈来实现。void QuickSortNonR(int* a,int left,int right){\tstack&amp;lt;int&amp;gt; s;\ts.push(right);\ts.push(left);\twhile(!s.empty())\t{\t\tint begin = s.top();\t\ts.pop();\t\tint end = s.top();\t\ts.p...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1519456118000,"createTime":1519456118000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79361823","articleType":1,"viewCount":199,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"找出数组中出现次数超过一半的数字","description":"题目：一个数组中有一个数字的次数超过了数组的一半，求出这个字符。如：int a[] = {2,3,2,2,2,2,2,5,4,1,2,3}，求出超过一半的数字是2。解法一：数组中有一个数字出现的次数超过了数组长度的一半，如果把数组排序，排序之后位于数组中间的数字一定是出现次数超过数组长度一半的数字。排序算法可以使用sort(快排)，它的时间复杂度为O(n*logn)。例如：{2,5,7,2,2","hasOriginal":true,"diggCount":0,"commentCount":2,"postTime":1516976780000,"createTime":1516976780000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79176936","articleType":1,"viewCount":3058,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"交换排序：冒泡排序和快速排序","description":"交换排序分为冒泡排序和快速排序。冒泡排序：    它是一种比较简单的排序方法，相邻两个元素两两比较，如果后一个比前一个大，就交换，每趟排序都可以将大的元素“浮”到顶端。外层循环循环n-1次，相当于排好了最大的n-1个元素的位置，则最后一个元素的位置就确定了。内层循环循环n-i次，两两交换，第一次排出最大元素在a[n-1]处；第二次循环n-1次，最大元素在a[n-2]处。时间复杂度：...","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1516891692000,"createTime":1516891692000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79164060","articleType":1,"viewCount":146,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"堆排序","description":"1.什么是堆？   堆其实是一颗完全二叉树，堆分为大堆和小堆。所谓大堆，就是父节点的值大于等于左右孩子结点的值，即a[i] \u003E= a[2*i+1] && a[i] \u003E= a[2*i+2]。所谓小堆，就是父节点的值小于等于左右孩子结点的值，即a[i] 堆排序是用堆这种数据结构设计的一种排序算法，是选择排序的一种。利用数组的特点快速定位到指定索引的元素。2.算法思想首先建一个大堆，堆顶","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1516545866000,"createTime":1516545866000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79121476","articleType":1,"viewCount":101,"rtype":"article"},{"type":"blog","formatTime":"3 年前","title":"选择排序的介绍","description":"选择排序是一种简单直观的排序算法，最大的数和最小的数不断交换，一趟排序下来，会将最大的数放在最后一个位置，最小的数放在起始位置。第二趟排序选出次大和次小的数，依次类推。算法思想：第一趟：MAX是9，MIN是0，MIN和begin交换，begin处为最小的数，MAX和end交换，end处为最大的数。begin++，end--，同理，begin处为次小的数，end处为次大的数。当beg","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1516523833000,"createTime":1516523833000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F79120854","articleType":1,"viewCount":136,"rtype":"article"},{"type":"blog","formatTime":"4 年前","title":"makefile介绍","description":"转自：http:\u002F\u002Fblog.chinaunix.net\u002Fuid-403164-id-2407545.html转自：https:\u002F\u002Fwww.cnblogs.com\u002Fqiaozhoulin\u002Fp\u002F4896326.html什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程","hasOriginal":false,"diggCount":0,"commentCount":0,"postTime":1511785880000,"createTime":1511785880000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F78648720","articleType":2,"viewCount":88,"rtype":"article"},{"type":"blog","formatTime":"4 年前","title":"插入排序","description":"插入排序  对一个已经有序的数据序列插入一个数。要求插入后此数据序列仍然有序。插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1511061831000,"createTime":1511061831000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F78573264","articleType":1,"viewCount":593,"rtype":"article"},{"type":"blog","formatTime":"4 年前","title":"Linux基本指令","description":"1.进入目录需要哪些权限。新建一个Experiment目录。 现在的目录user权限为可读（-r）、可写（-w）、可执行（-x）将读写执行权限去掉之后，我们发现进入不了目录了。给目录分别增加读、写、执行权限，我们发现在读权限、写权限、可读可写权限下进入不了目录，只有在可执行权限下才可以进入目录。总结：要进入一个目录必须要有可执行权限（","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1511010750000,"createTime":1511010750000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F78571202","articleType":1,"viewCount":143,"rtype":"article"},{"type":"blog","formatTime":"4 年前","title":"类和对象","description":"1：类和对象的相关概念 类（class\u002Fstruct）是一种非基本的数据类型，包括数据（成员变量）和程序（成员函数），类的访问限定符有三种，私有(private)、保护(protected)、公有(public)，通过给予成员变量和成员函数不同的访问限定符，达到限定对象访问的目的。类的访问限定符体现了面向对象的封装性。 一个类并没有分配实际的内存空间来储存它，只有当一个类实例化对象的时候，才给它分","hasOriginal":true,"diggCount":1,"commentCount":0,"postTime":1503482373000,"createTime":1503482373000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F77509181","articleType":1,"viewCount":147,"rtype":"article"},{"type":"blog","formatTime":"4 年前","title":"string之写时拷贝","description":"写时拷贝又叫引用计数的浅拷贝，浅拷贝不同于深拷贝的既拷空间又拷数据，浅拷贝只是拷贝数据，每开辟一块空间，随之有一个计数器，当有多个对象指向该空间时，引用计数++，每销毁一个对象，引用计数–，当引用计数为1时，才真正的销毁这块空间。第一种实现：开辟一块空间的同时，再开辟一块空间存放引用计数。 \u002F\u002F写时拷贝(第一种)class String{public:    String(char* st","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1503396339000,"createTime":1503396339000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F77483522","articleType":1,"viewCount":193,"rtype":"article"},{"type":"blog","formatTime":"4 年前","title":"智能指针","description":"1：智能指针的发展历史 \u003C1\u003E理解： 在动态内存分配中，为解决抛异常执行流跳转，导致内存泄漏的问题，产生了一个智能指针的类（smart pointer）,智能指针是基于RAII的设计思想（资源分配即初始化，资源的有效期与持有对象的生命期严格绑定），期待它能像指针一样，智能的管理指针所指向的动态资源的释放。  \u003C2\u003E开始是auto_ptr（C++98）：设计思想是管理权的转移，管理权在谁手上谁才有","hasOriginal":true,"diggCount":0,"commentCount":0,"postTime":1501842374000,"createTime":1501842374000,"url":"https:\u002F\u002Fblog.csdn.net\u002FQiana_\u002Farticle\u002Fdetails\u002F76691488","articleType":1,"viewCount":145,"rtype":"article"}]},"versionSwitchTips":[{"itemType":"","description":"1. 新版持续迭代中，用以满足大家的需求和体验；\n2. 若对新版有想法或建议，欢迎随时进行反馈！","title":"您即将切换至旧版个人主页","url":"","images":[""],"ext":{}}]}},"CFG":{"ALIPLAYER_VERSION":"v4","ALIPLAYER_H5_VERSION":"mobile_v1","ENV":"prod","ROOT_URL":"https:\u002F\u002Fcms-mall.csdn.net\u002F","VUE_APP_API_URL_SERVER":"http:\u002F\u002Fcms-community-api.internal.csdn.net\u002F","VUE_APP_API_URL":"https:\u002F\u002Fcms-api.csdn.net\u002F","LOGIN_URL":"https:\u002F\u002Fpassport.csdn.net\u002Faccount\u002Flogin","VUE_APP_COMMUNITY_API_URL":"https:\u002F\u002Fcommunity-api.csdn.net\u002F","VUE_APP_CCLOUD_API_URL":"http:\u002F\u002Fcommunity-cloud-api.csdn.net\u002F","VUE_APP_COMMUNITY_ASK_API_URL":"https:\u002F\u002Fmp-ask.csdn.net\u002F","VUE_APP_ME_URL":"https:\u002F\u002Fme.csdn.net\u002F","SENTRY_URL":"https:\u002F\u002Fecf38ba949474cb891ff04c224d990dd@sentry.csdn.net\u002F20","VUE_USER_PROFILE":"https:\u002F\u002Fblog.csdn.net\u002F","VUE_MINI_SHOP":"https:\u002F\u002Fmall.csdn.net\u002F","APPKEY":"203871969","APPSECRET":"UZCZUodD1gRrgGldZlsi7bd1XcXXlrft"},"queries":{"pageId":[],"domain":["blog.csdn.net\u002Fuser"],"username":["Qiana_"],"hostname":["blog.csdn.net"],"size":100},"basePath":"cms-user.internal.csdn.net\u002Fuser\u002FQiana_","canonical":"https:\u002F\u002Fblog.csdn.net\u002FQiana_","active":0,"navBarFixed":false};</script><script type="text/javascript" src="https://csdnimg.cn/release/cmsfe/public/js/runtime.5aafb0f2.js"></script><script type="text/javascript" src="https://csdnimg.cn/release/cmsfe/public/js/chunk/common.2750a17e.js"></script><script type="text/javascript" src="https://csdnimg.cn/release/cmsfe/public/js/chunk/tpl/user-profile/index.979092ae.js"></script></body> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> <!----> 
        <script>
          window.csdn.sideToolbar = {
            options: {
              contentEl: document.getElementsByClassName("user-profile-body-right")[0]
            }
          };
        </script>
       
         <script src="https://g.csdnimg.cn/side-toolbar/3.0/side-toolbar.js" ></script>
       
         <script src="https://g.csdnimg.cn/common/csdn-toolbar/csdn-toolbar.js"></script>
       <!----> <!----> <!----> <!----> 
        <script src="https://g.csdnimg.cn/user-medal/1.0.6/user-medal.js"></script>
      </html>